<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Professional Watermark Application</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Lato:wght@400;700&family=Merriweather:wght@400;700&family=Montserrat:wght@400;700&family=Open+Sans:wght@400;700&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700&family=Raleway:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Light Mode Colors */
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #64748b;
            --background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            --surface: #ffffff;
            --surface-2: #f8fafc;
            --surface-3: #e2e8f0;
            --text: #0f172a;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --error: #dc2626;
            --warning: #d97706;
            --success: #059669;
            --info: #0284c7;
            --shadow: rgba(0, 0, 0, 0.08);
            --shadow-hover: rgba(0, 0, 0, 0.12);
        }

        [data-theme="dark"] {
            /* Dark Mode Colors */
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --secondary: #64748b;
            --background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            --surface: #1e293b;
            --surface-2: #334155;
            --surface-3: #475569;
            --text: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3af;
            --border: #334155;
            --error: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
            --info: #06b6d4;
            --shadow: rgba(0, 0, 0, 0.25);
            --shadow-hover: rgba(0, 0, 0, 0.35);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--background);
            min-height: 100vh;
            padding: 20px;
            color: var(--text);
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .header-content h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: white;
            margin-bottom: 10px;
        }

        .header-content p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .theme-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .help-btn {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
            padding: 12px 20px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .help-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .upload-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }

        .upload-box {
            background: var(--surface);
            border-radius: 20px;
            padding: 35px;
            border: 3px dashed var(--border);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            min-height: 320px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .upload-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 49%, var(--primary) 50%, var(--primary) 51%, transparent 52%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .upload-box.dragover {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.05);
            transform: scale(1.02);
        }

        .upload-box.dragover::before {
            opacity: 0.1;
        }

        .upload-box:hover {
            border-color: var(--primary);
            transform: translateY(-8px);
            box-shadow: 0 15px 35px var(--shadow-hover);
        }

        .upload-box.has-image {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.05);
        }

        .upload-icon {
            font-size: 60px;
            margin-bottom: 20px;
            opacity: 0.8;
        }

        .upload-box h3 {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text);
        }

        .upload-box p {
            color: var(--text-muted);
            font-size: 0.95rem;
            margin-bottom: 15px;
        }

        .file-info {
            background: var(--surface-2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .gallery-item {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px var(--shadow);
            transition: transform 0.3s ease;
        }

        .gallery-item:hover {
            transform: scale(1.05);
        }

        .gallery-item img {
            width: 100%;
            height: 80px;
            object-fit: cover;
        }

        .gallery-item .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--error);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .gallery-item:hover .remove-btn {
            opacity: 1;
        }

        .preview-section {
            background: var(--surface);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 25px;
            display: none;
        }

        .preview-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-canvas {
            max-width: 100%;
            max-height: 400px;
            border-radius: 12px;
            box-shadow: 0 8px 25px var(--shadow);
            display: block;
            margin: 0 auto;
        }

        .settings-panel {
            background: var(--surface);
            border-radius: 20px;
            padding: 35px;
            margin-bottom: 25px;
        }

        .settings-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 25px;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 1px solid var(--border);
        }

        .tab-btn {
            padding: 12px 20px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
            position: relative;
        }

        .tab-btn.active {
            color: var(--primary);
            background: var(--surface-2);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }

        .setting-item label {
            display: block;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text);
            font-size: 0.95rem;
        }

        .setting-value {
            color: var(--primary);
            font-weight: 700;
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--surface-3);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .setting-item input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .setting-item input[type="range"]::-moz-range-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: var(--surface-3);
            border-radius: 5px;
            border: none;
        }

        .setting-item input[type="range"]::-ms-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: transparent;
            border-color: transparent;
            color: transparent;
        }

        .setting-item input[type="range"]::-ms-fill-lower,
        .setting-item input[type="range"]::-ms-fill-upper {
            background: var(--surface-3);
            border-radius: 5px;
        }

        .setting-item input[type="range"]::-ms-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .setting-item input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 10px;
            background: var(--surface-2);
            color: var(--text);
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .setting-item input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .setting-item select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 10px;
            background: var(--surface-2);
            color: var(--text);
            font-size: 0.95rem;
            cursor: pointer;
        }

        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .color-picker {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .mode-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 150px;
            padding: 15px 20px;
            border: 2px solid var(--border);
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--surface);
            color: var(--text);
        }

        .mode-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px var(--shadow-hover);
        }

        .position-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 20px;
            background: var(--surface-2);
            padding: 25px;
            border-radius: 15px;
        }

        .position-btn {
            padding: 20px;
            border: 2px solid var(--border);
            border-radius: 10px;
            background: var(--surface);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            color: var(--text);
            font-size: 0.9rem;
        }

        .position-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .position-btn:hover {
            transform: scale(1.05);
        }

        .process-section {
            background: var(--surface);
            border-radius: 20px;
            padding: 35px;
            margin-bottom: 25px;
            text-align: center;
        }

        .process-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 25px;
        }

        .process-btn {
            padding: 18px 40px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }

        .process-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .process-btn:hover::before {
            left: 100%;
        }

        .process-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
        }

        .process-btn:disabled {
            background: var(--surface-3);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .secondary-btn {
            background: var(--surface-2);
            color: var(--text);
            border: 2px solid var(--border);
        }

        .secondary-btn:hover {
            background: var(--surface-3);
            box-shadow: 0 8px 20px var(--shadow-hover);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px 0;
            padding: 20px;
            background: var(--surface-2);
            border-radius: 15px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2.2rem;
            font-weight: 700;
            color: var(--primary);
            display: block;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .progress-container {
            margin-top: 25px;
        }

        .progress-bar {
            width: 100%;
            height: 35px;
            background: var(--surface-2);
            border-radius: 18px;
            overflow: hidden;
            box-shadow: inset 0 2px 5px var(--shadow);
            display: none;
        }

        .progress-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-dark) 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.95rem;
            position: relative;
            overflow: hidden;
        }

        .progress-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 25%, rgba(255, 255, 255, 0.1) 25%, rgba(255, 255, 255, 0.1) 50%, transparent 50%, transparent 75%, rgba(255, 255, 255, 0.1) 75%);
            background-size: 20px 20px;
            animation: progress-animation 1s linear infinite;
        }

        @keyframes progress-animation {
            0% { transform: translateX(-20px); }
            100% { transform: translateX(20px); }
        }

        .results-section {
            background: var(--surface);
            border-radius: 20px;
            padding: 35px;
            margin-top: 25px;
            display: none;
        }

        .results-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 25px;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .results-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .download-all-btn {
            padding: 15px 35px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            background: var(--warning);
            color: white;
            transition: all 0.3s ease;
        }

        .download-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }

        .clear-results-btn {
            background: var(--error);
        }

        .clear-results-btn:hover {
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 25px;
        }

        .result-item {
            border: 2px solid var(--border);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            background: var(--surface);
        }

        .result-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px var(--shadow-hover);
            border-color: var(--primary);
        }

        .result-item img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px var(--shadow);
        }

        .result-item .file-name {
            font-weight: 600;
            color: var(--text);
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .result-item .file-size {
            color: var(--text-muted);
            font-size: 0.8rem;
            margin-bottom: 15px;
        }

        .download-btns {
            display: flex;
            gap: 10px;
        }

        .download-btn {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            font-size: 0.9rem;
        }

        .download-btn.png {
            background: var(--success);
        }

        .download-btn.jpg {
            background: var(--info);
        }

        .download-btn.webp {
            background: var(--secondary);
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 18px 25px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            max-width: 400px;
            box-shadow: 0 8px 25px var(--shadow);
            animation: slideInAlert 0.4s ease-out;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .alert-error { background: var(--error); }
        .alert-warning { background: var(--warning); }
        .alert-success { background: var(--success); }
        .alert-info { background: var(--info); }

        .alert .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .alert .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        @keyframes slideInAlert {
            from { 
                transform: translateX(100%) scale(0.8);
                opacity: 0;
            }
            to { 
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .loading-content {
            background: var(--surface);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--surface-3);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        input[type="file"] {
            display: none;
        }

        .keyboard-shortcuts {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 15px;
            font-size: 0.8rem;
            color: var(--text-muted);
            box-shadow: 0 4px 15px var(--shadow);
            max-width: 250px;
            z-index: 100;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .shortcut-key {
            background: var(--surface-2);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.75rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 10px;
            }
            
            .header {
                flex-direction: column;
                text-align: center;
            }
            
            .header-content h1 {
                font-size: 2rem;
            }
            
            .upload-section {
                grid-template-columns: 1fr;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
            }
            
            .mode-buttons {
                flex-direction: column;
            }
            
            .mode-btn {
                min-width: auto;
            }
            
            .process-controls {
                flex-direction: column;
            }
            
            .stats {
                gap: 20px;
            }
            
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            .alert {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
        }

        /* Accessibility Improvements */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High Contrast Mode */
        @media (prefers-contrast: high) {
            :root {
                --border: #000000;
                --shadow: rgba(0, 0, 0, 0.5);
            }
            
            [data-theme="dark"] {
                --border: #ffffff;
            }
        }

        /* Focus Styles for Accessibility */
        .upload-box:focus-visible,
        .mode-btn:focus-visible,
        .position-btn:focus-visible,
        .process-btn:focus-visible,
        .download-btn:focus-visible,
        .tab-btn:focus-visible {
            outline: 3px solid var(--primary);
            outline-offset: 2px;
        }

        input:focus-visible,
        select:focus-visible {
            outline: 3px solid var(--primary);
            outline-offset: 2px;
        }

        /* Print Styles */
        @media print {
            .header-controls,
            .process-section,
            .keyboard-shortcuts {
                display: none;
            }
        }

        /* Preset Butonlarƒ± Stili */
        .preset-btn {
            background: var(--surface-2);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            color: var(--text);
        }

        .preset-btn:hover {
            background: var(--surface-3);
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow-hover);
        }

        .preset-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Geli≈ümi≈ü Progress Bar */
        .advanced-progress {
            position: relative;
            margin: 20px 0;
        }

        .progress-details {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .speed-indicator {
            background: var(--surface-2);
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* Performance Badges */
        .perf-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin: 0 5px;
        }

        .perf-badge.fast { background: var(--success); color: white; }
        .perf-badge.medium { background: var(--warning); color: white; }
        .perf-badge.slow { background: var(--error); color: white; }

        /* Favori Yƒ±ldƒ±z Butonu */
        .favorite-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 5px;
            transition: all 0.3s ease;
        }

        .favorite-btn:hover,
        .favorite-btn.active {
            color: #ffd700;
            transform: scale(1.2);
        }

        /* Smart Suggestions Modal */
        .suggestion-item {
            background: var(--surface-2);
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid var(--primary);
        }

        .apply-suggestion-btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 5px 12px;
            margin-top: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .apply-suggestion-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        /* Quick Actions */
        .quick-actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .quick-action-card {
            background: var(--surface-2);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quick-action-card:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px var(--shadow-hover);
        }

        /* Enhanced File Info */
        .file-info.enhanced {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 15px;
        }

        .file-specs {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* Loading States */
        .processing-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--warning);
            color: white;
            border-radius: 20px;
            font-size: 0.85rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Success States */
        .success-indicator {
            color: var(--success);
            font-weight: 600;
        }

        /* Smart Tooltips */
        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--text);
            color: var(--surface);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .tooltip:hover::after {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header" role="banner">
            <div class="header-content">
                <h1>üé® Advanced Professional Watermark Application</h1>
                <p>Professional watermarking with real-time preview and advanced features</p>
            </div>
            <div class="header-controls">
                <a href="https://ko-fi.com/solderett" target="_blank" class="kofi-btn" style="background: #13C3FF; color: white; text-decoration: none; padding: 12px 20px; border-radius: 50px; font-weight: 600; margin-right: 15px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.3s ease;" onmouseover="this.style.background='#0FB3EE'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='#13C3FF'; this.style.transform='translateY(0)'">
                    ‚òï Support Me
                </a>
                <button class="help-btn" onclick="showHelp()" aria-label="Help">
                    ‚ùì Help
                </button>
                <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
                    üåô Dark Mode
                </button>
            </div>
        </header>

        <main role="main">
            <section class="upload-section" aria-label="File upload">
                <div class="upload-box" id="mainImageBox" tabindex="0" role="button" aria-label="Upload main images">
                    <div class="upload-icon">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                            <circle cx="12" cy="13" r="4"/>
                        </svg>
                    </div>
                    <h3>Upload Main Images</h3>
                    <p>Click or drag images here (PNG, JPG, WEBP)</p>
                    <p style="font-size: 0.85rem; color: var(--text-muted);">Max size: 10MB</p>
                    <input type="file" id="mainImageInput" accept="image/*" multiple aria-label="Select main image files">
                    <div class="image-gallery" id="mainGallery" role="list"></div>
                    <button class="clear-images-btn" onclick="clearAllImages(event)" style="display: none; margin-top: 15px; padding: 8px 16px; background: var(--error); color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 10; position: relative;" id="clearImagesBtn">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px;">
                            <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14zM10 11v6M14 11v6"/>
                        </svg>
                        Clear All
                    </button>
                </div>

                <div class="upload-box" id="watermarkBox" tabindex="0" role="button" aria-label="Upload watermark">
                    <div class="upload-icon">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
                        </svg>
                    </div>
                    <h3>Upload Watermark/Logo</h3>
                    <p>We recommend transparent PNG logos</p>
                    <p style="font-size: 0.85rem; color: var(--text-muted);">Max size: 5MB</p>
                    <input type="file" id="watermarkInput" accept="image/*" aria-label="Select watermark file">
                </div>
            </section>

            <section class="preview-section" id="previewSection" aria-label="Preview">
                <h2 class="preview-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    Real-time Preview
                </h2>
                <canvas class="preview-canvas" id="previewCanvas" aria-label="Watermark preview" tabindex="0"></canvas>
                <div class="file-info" id="previewInfo"></div>
            </section>

            <section class="settings-panel" aria-label="Settings">
                <h2 class="settings-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                    Watermark Settings
                </h2>
                
                <div class="settings-tabs" role="tablist">
                    <button class="tab-btn active" role="tab" aria-selected="true" aria-controls="image-tab" id="image-tab-btn" onclick="switchTab('image')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <path d="M21 15l-5-5L5 21"/>
                        </svg>
                        Image
                    </button>
                    <button class="tab-btn" role="tab" aria-selected="false" aria-controls="text-tab" id="text-tab-btn" onclick="switchTab('text')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                            <path d="M14 2v6h6M16 13H8M16 17H8M10 9H8"/>
                        </svg>
                        Text
                    </button>
                    <button class="tab-btn" role="tab" aria-selected="false" aria-controls="qr-tab" id="qr-tab-btn" onclick="switchTab('qr')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <path d="M7 7h3v3H7z"></path>
                            <path d="M14 7h3v3h-3z"></path>
                            <path d="M7 14h3v3H7z"></path>
                            <path d="M14 14h3v3h-3z"></path>
                        </svg>
                        QR Code
                    </button>
                    <button class="tab-btn" role="tab" aria-selected="false" aria-controls="effects-tab" id="effects-tab-btn" onclick="switchTab('effects')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                        Effects
                    </button>
                    <button class="tab-btn" role="tab" aria-selected="false" aria-controls="export-tab" id="export-tab-btn" onclick="switchTab('export')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7,10 12,15 17,10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        Export
                    </button>
                </div>

                <div class="tab-content active" id="image-tab" role="tabpanel" aria-labelledby="image-tab-btn">
                    <div class="settings-grid">
                        <div class="setting-item">
                            <label for="countSlider">Watermark Count: <span class="setting-value" id="countValue">5</span></label>
                            <input type="range" id="countSlider" min="1" max="200" value="5" aria-describedby="count-desc">
                            <small id="count-desc">For Grid/Random modes. (In Position mode, it's always 1)</small>
                        </div>

                        <div class="setting-item">
                            <label for="opacitySlider">Opacity: <span class="setting-value" id="opacityValue">50</span>%</label>
                            <input type="range" id="opacitySlider" min="0" max="100" value="50">
                        </div>

                        <div class="setting-item">
                            <label for="sizeSlider">Size: <span class="setting-value" id="sizeValue">15</span>%</label>
                            <input type="range" id="sizeSlider" min="1" max="100" value="15">
                        </div>

                        <div class="setting-item">
                            <label for="rotationSlider">Rotation: <span class="setting-value" id="rotationValue">0</span>¬∞</label>
                            <input type="range" id="rotationSlider" min="-180" max="180" value="0">
                        </div>

                        <div class="setting-item">
                            <label for="blendMode">Blend Mode:</label>
                            <select id="blendMode">
                                <option value="normal">Normal</option>
                                <option value="multiply">Multiply</option>
                                <option value="screen">Screen</option>
                                <option value="overlay">Overlay</option>
                                <option value="soft-light">Soft Light</option>
                                <option value="hard-light">Hard Light</option>
                                <option value="color-dodge">Color Dodge</option>
                                <option value="color-burn">Color Burn</option>
                            </select>
                        </div>

                        <div class="setting-item">
                            <label for="paddingSlider">Padding: <span class="setting-value" id="paddingValue">20</span>px</label>
                            <input type="range" id="paddingSlider" min="0" max="100" value="20">
                        </div>

                        <div class="setting-item">
                            <label for="qualitySlider">Output Quality: <span class="setting-value" id="qualityValue">85</span>%</label>
                            <input type="range" id="qualitySlider" min="10" max="100" value="85">
                        </div>

                        <div class="setting-item">
                            <label for="preserveFormat">
                                <input type="checkbox" id="preserveFormat" checked>
                                Preserve Original Format
                            </label>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="text-tab" role="tabpanel" aria-labelledby="text-tab-btn">
                    <div class="settings-grid">
                        <div class="setting-item">
                            <label for="textContent">Text Content:</label>
                            <input type="text" id="textContent" placeholder="¬© 2024 Company Name" maxlength="100">
                        </div>

                        <div class="setting-item">
                            <label for="textSize">Text Size: <span class="setting-value" id="textSizeValue">24</span>px</label>
                            <input type="range" id="textSizeSlider" min="8" max="120" value="24">
                        </div>

                        <div class="setting-item">
                            <label for="fontFamily">Font:</label>
                            <select id="fontFamily">
                                <option value="Arial">Arial</option>
                                <option value="Helvetica">Helvetica</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Impact">Impact</option>
                                <option value="Inter">Inter</option>
                                <option value="Roboto">Roboto</option>
                                <option value="Open Sans">Open Sans</option>
                                <option value="Lato">Lato</option>
                                <option value="Montserrat">Montserrat</option>
                                <option value="Oswald">Oswald</option>
                                <option value="Raleway">Raleway</option>
                                <option value="Merriweather">Merriweather</option>
                                <option value="Playfair Display">Playfair Display</option>
                            </select>
                        </div>

                        <div class="setting-item">
                            <label>Text Color:</label>
                            <div class="color-picker-wrapper">
                                <input type="color" id="textColor" class="color-picker" value="#ffffff">
                                <span id="textColorValue">#ffffff</span>
                            </div>
                        </div>

                        <div class="setting-item">
                            <label for="textStroke">Stroke Width: <span class="setting-value" id="textStrokeValue">2</span>px</label>
                            <input type="range" id="textStrokeSlider" min="0" max="10" value="2">
                        </div>

                        <div class="setting-item">
                            <label>Stroke Color:</label>
                            <div class="color-picker-wrapper">
                                <input type="color" id="textStrokeColor" class="color-picker" value="#000000">
                                <span id="textStrokeColorValue">#000000</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="qr-tab" role="tabpanel" aria-labelledby="qr-tab-btn">
                    <div class="settings-grid">
                        <div class="setting-item">
                            <label for="qrContent">QR Code Content:</label>
                            <input type="text" id="qrContent" placeholder="Enter text or URL for QR code" maxlength="500">
                        </div>

                        <div class="setting-item">
                            <label>QR Foreground Color:</label>
                            <div class="color-picker-wrapper">
                                <input type="color" id="qrColor" class="color-picker" value="#000000">
                                <span id="qrColorValue">#000000</span>
                            </div>
                        </div>

                        <div class="setting-item">
                            <label>QR Background Color:</label>
                            <div class="color-picker-wrapper">
                                <input type="color" id="qrBgColor" class="color-picker" value="#ffffff">
                                <span id="qrBgColorValue">#ffffff</span>
                            </div>
                        </div>

                        <div class="setting-item">
                            <label>QR Code Actions:</label>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                                <button class="process-btn" onclick="generateAndSetQR()" style="padding: 8px 15px; display: flex; align-items: center; gap: 6px;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                        <path d="M7 7h3v3H7z"></path>
                                        <path d="M14 7h3v3h-3z"></path>
                                        <path d="M7 14h3v3H7z"></path>
                                    </svg>
                                    Generate QR
                                </button>
                                <button class="secondary-btn" onclick="restoreUploadedWatermark()" id="restoreWatermarkBtn" style="padding: 8px 15px; display: none; align-items: center; gap: 6px;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="23 4 23 10 17 10"></polyline>
                                        <polyline points="1 20 1 14 7 14"></polyline>
                                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                                    </svg>
                                    Restore Original
                                </button>
                            </div>
                        </div>

                        <div class="setting-item">
                            <label>QR Preview:</label>
                            <div id="qrPreviewContainer" style="margin-top: 10px; min-height: 50px; display: flex; align-items: center; justify-content: center; background: var(--surface-2); border-radius: 8px; padding: 20px;">
                                <span style="color: var(--text-muted);">QR code will appear here after generation</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="effects-tab" role="tabpanel" aria-labelledby="effects-tab-btn">
                    <div class="settings-grid">
                        <div class="setting-item">
                            <label for="shadowBlur">Shadow Blur: <span class="setting-value" id="shadowBlurValue">0</span>px</label>
                            <input type="range" id="shadowBlurSlider" min="0" max="50" value="0">
                        </div>

                        <div class="setting-item">
                            <label for="shadowOffset">Shadow Distance: <span class="setting-value" id="shadowOffsetValue">0</span>px</label>
                            <input type="range" id="shadowOffsetSlider" min="0" max="20" value="0">
                        </div>

                        <div class="setting-item">
                            <label>Shadow Color:</label>
                            <div class="color-picker-wrapper">
                                <input type="color" id="shadowColor" class="color-picker" value="#000000">
                                <span id="shadowColorValue">#000000</span>
                            </div>
                        </div>

                        <div class="setting-item">
                            <label for="brightness">Brightness: <span class="setting-value" id="brightnessValue">100</span>%</label>
                            <input type="range" id="brightnessSlider" min="20" max="200" value="100">
                        </div>

                        <div class="setting-item">
                            <label for="contrast">Contrast: <span class="setting-value" id="contrastValue">100</span>%</label>
                            <input type="range" id="contrastSlider" min="20" max="200" value="100">
                        </div>

                        <div class="setting-item">
                            <label for="saturation">Saturation: <span class="setting-value" id="saturationValue">100</span>%</label>
                            <input type="range" id="saturationSlider" min="0" max="200" value="100">
                        </div>
                    </div>
                </div>

                <div class="mode-buttons" role="group" aria-label="Watermark distribution modes">
                    <button class="mode-btn active" onclick="setMode('position', this)" aria-pressed="true" aria-label="Specific position mode">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                            <circle cx="12" cy="10" r="3"/>
                        </svg>
                        Specific Position
                    </button>
                    <button class="mode-btn" onclick="setMode('random', this)" aria-pressed="false" aria-label="Random distribution mode">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="6" height="6" rx="1"/>
                            <rect x="15" y="3" width="6" height="6" rx="1"/>
                            <rect x="3" y="15" width="6" height="6" rx="1"/>
                            <rect x="15" y="15" width="6" height="6" rx="1"/>
                        </svg>
                        Random Distribution
                    </button>
                    <button class="mode-btn" onclick="setMode('grid', this)" aria-pressed="false" aria-label="Grid distribution mode">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="7" height="7"/>
                            <rect x="14" y="3" width="7" height="7"/>
                            <rect x="3" y="14" width="7" height="7"/>
                            <rect x="14" y="14" width="7" height="7"/>
                        </svg>
                        Grid Distribution
                    </button>
                    <button class="mode-btn" onclick="setMode('pattern', this)" aria-pressed="false" aria-label="Pattern distribution mode">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M23 6l-9.5 9.5-5-5L1 18"/>
                            <path d="M17 6h6v6"/>
                        </svg>
                        Pattern Distribution
                    </button>
                </div>

                <div class="position-grid" id="positionGrid" role="group" aria-label="Position options">
                    <button class="position-btn active" onclick="setPosition('top-left', this)" aria-pressed="true" aria-label="Top left corner">‚Üñ Top Left</button>
                    <button class="position-btn" onclick="setPosition('top-center', this)" aria-pressed="false" aria-label="Top center">‚Üë Top Center</button>
                    <button class="position-btn" onclick="setPosition('top-right', this)" aria-pressed="false" aria-label="Top right corner">‚Üó Top Right</button>
                    <button class="position-btn" onclick="setPosition('left-center', this)" aria-pressed="false" aria-label="Left center">‚Üê Left Center</button>
                    <button class="position-btn" onclick="setPosition('center', this)" aria-pressed="false" aria-label="Center">‚Ä¢ Center</button>
                    <button class="position-btn" onclick="setPosition('right-center', this)" aria-pressed="false" aria-label="Right center">‚Üí Right Center</button>
                    <button class="position-btn" onclick="setPosition('bottom-left', this)" aria-pressed="false" aria-label="Bottom left corner">‚Üô Bottom Left</button>
                    <button class="position-btn" onclick="setPosition('bottom-center', this)" aria-pressed="false" aria-label="Bottom center">‚Üì Bottom Center</button>
                    <button class="position-btn" onclick="setPosition('bottom-right', this)" aria-pressed="false" aria-label="Bottom right corner">‚Üò Bottom Right</button>
                </div>

                <!-- Advanced Export Settings -->
                <div class="tab-content" id="export-tab" role="tabpanel" aria-labelledby="export-tab-btn" style="display: none;">
                    <h3 style="color: var(--text); margin-bottom: 20px;">üìÅ Advanced Export Options</h3>
                    <div class="settings-grid">
                        <div class="setting-item">
                            <label for="jpgQuality">JPG Quality: <span class="setting-value" id="jpgQualityValue">95</span>%</label>
                            <input type="range" id="jpgQualitySlider" min="60" max="100" value="95">
                        </div>
                        
                        <div class="setting-item">
                            <label for="webpQuality">WEBP Quality: <span class="setting-value" id="webpQualityValue">90</span>%</label>
                            <input type="range" id="webpQualitySlider" min="60" max="100" value="90">
                        </div>
                        
                        <div class="setting-item">
                            <label>Bulk Download Formats:</label>
                            <div style="display: flex; gap: 10px; margin-top: 10px;">
                                <label><input type="checkbox" id="exportPNG" checked> PNG</label>
                                <label><input type="checkbox" id="exportJPG"> JPG</label>
                                <label><input type="checkbox" id="exportWEBP"> WEBP</label>
                            </div>
                        </div>
                        
                        <div class="setting-item">
                            <label>Performance Mode:</label>
                            <select id="performanceMode">
                                <option value="balanced">Balanced</option>
                                <option value="quality">High Quality</option>
                                <option value="speed">High Speed</option>
                            </select>
                        </div>
                        
                        <div class="setting-item">
                            <label>Multi-format Download:</label>
                            <button class="process-btn secondary-btn" onclick="downloadAllFormats()" style="width: 100%; margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line></svg>
                                Download All Formats
                            </button>
                            <small style="color: var(--text-muted); margin-top: 8px; display: block;">
                                Downloads selected formats as ZIP file
                            </small>
                        </div>
                    </div>
                </div>

                <!-- Quick Presets -->
                <div class="quick-presets" style="margin-top: 25px;">
                    <h3 style="color: var(--text); margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
                        Quick Settings
                    </h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <button class="preset-btn" onclick="applyPreset('subtle')" data-preset="subtle">
                            <div style="font-weight: 600;">Subtle Watermark</div>
                            <small>Low opacity, small size</small>
                        </button>
                        <button class="preset-btn" onclick="applyPreset('standard')" data-preset="standard">
                            <div style="font-weight: 600;">Standard</div>
                            <small>Medium opacity, normal size</small>
                        </button>
                        <button class="preset-btn" onclick="applyPreset('bold')" data-preset="bold">
                            <div style="font-weight: 600;">Bold</div>
                            <small>High opacity, large size</small>
                        </button>
                        <button class="preset-btn" onclick="applyPreset('corner')" data-preset="corner">
                            <div style="font-weight: 600;">Corner Logo</div>
                            <small>Bottom right corner, small</small>
                        </button>
                    </div>
                </div>

                <div class="settings-grid" style="margin-top: 20px;">
                    <div class="setting-item">
                        <label>Preset Management:</label>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                            <button class="secondary-btn" style="padding: 8px 15px; display: flex; align-items: center; gap: 6px;" onclick="savePreset()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg> Save
                            </button>
                            <button class="secondary-btn" style="padding: 8px 15px; display: flex; align-items: center; gap: 6px;" onclick="loadPreset()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg> Load
                            </button>
                            <button class="secondary-btn" style="padding: 8px 15px; display: flex; align-items: center; gap: 6px;" onclick="resetSettings()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg> Reset
                            </button>
                            <button class="secondary-btn" style="padding: 8px 15px; display: flex; align-items: center; gap: 6px;" onclick="saveToFavorites()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg> Favorite
                            </button>
                        </div>
                    </div>
                </div>
            
                <!-- Remove this script block as function is defined below -->
            </section>

            <section class="process-section" aria-label="Processing">
                <div class="process-controls">
                    <button class="process-btn" id="processBtn" onclick="processAllImages()" disabled aria-describedby="process-desc" style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                        Process All Images
                    </button>
                    <button class="process-btn secondary-btn" onclick="previewSingle()" id="previewBtn" disabled style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                        Preview
                    </button>
                    <button class="process-btn secondary-btn" onclick="undoLast()" id="undoBtn" disabled style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg>
                        Undo
                    </button>
                </div>
                <small id="process-desc">Activated after uploading main images and watermark</small>
                
                <div class="stats" id="stats" style="display: none;">
                    <div class="stat-item">
                        <span class="stat-number" id="totalImages">0</span>
                        <div class="stat-label">Total Images</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="processedImages">0</span>
                        <div class="stat-label">Processed</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="processingTime">0</span>
                        <div class="stat-label">Time (s)</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="totalSize">0</span>
                        <div class="stat-label">Total MB</div>
                    </div>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>
            </section>

            <section class="results-section" id="resultsSection" aria-label="Results">
                <h2 class="results-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                    Processed Images
                </h2>
                <div class="results-controls">
                    <button class="download-all-btn" onclick="downloadAllImages()" style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line></svg>
                        Download All (ZIP)
                    </button>
                    <button class="download-all-btn clear-results-btn" onclick="clearResults()" style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        Clear Results
                    </button>
                    <button class="download-all-btn secondary-btn" onclick="shareResults()" style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg>
                        Share
                    </button>
                </div>
                <div class="results-grid" id="resultsGrid"></div>
            </section>
        </main>

        <div class="keyboard-shortcuts" id="keyboardShortcuts">
            <h4 style="margin-bottom: 10px; color: var(--text);">Keyboard Shortcuts</h4>
            <div class="shortcut-item">
                <span>Select File</span>
                <kbd class="shortcut-key">Ctrl+O</kbd>
            </div>
            <div class="shortcut-item">
                <span>Process</span>
                <kbd class="shortcut-key">Ctrl+Enter</kbd>
            </div>
            <div class="shortcut-item">
                <span>Undo</span>
                <kbd class="shortcut-key">Ctrl+Z</kbd>
            </div>
            <div class="shortcut-item">
                <span>Toggle Theme</span>
                <kbd class="shortcut-key">Ctrl+T</kbd>
            </div>
            <div class="shortcut-item">
                <span>Help</span>
                <kbd class="shortcut-key">F1</kbd>
            </div>
        </div>
    </div>

    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script>
        // Enhanced Global Configuration
        const CONFIG = {
            MAX_FILE_SIZE: 20 * 1024 * 1024, // 20MB
            MAX_WATERMARK_SIZE: 10 * 1024 * 1024, // 10MB
            SUPPORTED_FORMATS: ['image/jpeg', 'image/png', 'image/webp', 'image/gif'],
            MAX_CANVAS_SIZE: 32000, // Increased for long images
            WORKER_ENABLED: typeof Worker !== 'undefined',
            // New performance and feature configs
            BATCH_SIZE: 5, // Process 5 images at a time
            MEMORY_THRESHOLD: 512 * 1024 * 1024, // 512MB memory limit
            AUTOSAVE_INTERVAL: 30000, // 30 seconds
            THUMBNAIL_SIZE: { width: 150, height: 150 },
            QUALITY_PRESETS: {
                draft: { jpeg: 0.6, webp: 0.5, png: 0.7 },
                standard: { jpeg: 0.8, webp: 0.75, png: 0.85 },
                high: { jpeg: 0.95, webp: 0.9, png: 1.0 }
            },
            SUPPORTED_LANGUAGES: ['tr', 'en', 'de', 'fr', 'es'],
            CLOUD_STORAGE: {
                maxFileSize: 50 * 1024 * 1024,
                supportedProviders: ['gdrive', 'dropbox', 'onedrive']
            }
        };

        // Advanced Feature Flags
        const FEATURES = {
            AI_POSITIONING: false,
            CLOUD_SYNC: false,
            COLLABORATIVE_EDITING: false,
            VIDEO_WATERMARKING: false,
            BATCH_TEMPLATES: true,
            ADVANCED_ANALYTICS: true,
            OFFLINE_MODE: true,
            USE_WEBWORKER: typeof OffscreenCanvas !== 'undefined'
        };

        // ============================================
        // HIGH PRIORITY 1: Image Cache System (LRU)
        // ============================================
        class ImageCache {
            constructor(maxSize = 50) {
                this.cache = new Map();
                this.maxSize = maxSize;
                this.accessOrder = [];
            }

            set(key, value) {
                if (this.cache.size >= this.maxSize) {
                    const lruKey = this.accessOrder.shift();
                    this.cache.delete(lruKey);
                }
                this.cache.set(key, value);
                this.accessOrder.push(key);
            }

            get(key) {
                if (this.cache.has(key)) {
                    this.accessOrder = this.accessOrder.filter(k => k !== key);
                    this.accessOrder.push(key);
                    return this.cache.get(key);
                }
                return null;
            }

            has(key) { return this.cache.has(key); }
            clear() { this.cache.clear(); this.accessOrder = []; }
        }

        const imageCache = new ImageCache(30);

        // ============================================
        // HIGH PRIORITY 2: Progressive Export with toBlob()
        // ============================================
        class ProgressiveExporter {
            static async canvasToBlob(canvas, format = 'image/jpeg', quality = 0.85) {
                return new Promise((resolve, reject) => {
                    canvas.toBlob(blob => blob ? resolve(blob) : reject(new Error('Blob failed')), format, quality);
                });
            }

            static async blobToDataURL(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            static async exportImage(canvas, format, quality) {
                try {
                    const blob = await this.canvasToBlob(canvas, format, quality);
                    return { blob, dataURL: await this.blobToDataURL(blob), size: blob.size };
                } catch (e) {
                    const dataURL = canvas.toDataURL(format, quality);
                    return { blob: null, dataURL, size: Math.round(dataURL.length * 0.75) };
                }
            }

            static async downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.click();
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            }
        }

        // ============================================
        // HIGH PRIORITY 3: Lazy Loading for Gallery
        // ============================================
        class LazyLoadManager {
            constructor() {
                this.observer = null;
                if ('IntersectionObserver' in window) {
                    this.observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const img = entry.target;
                                if (img.dataset.src) {
                                    img.src = img.dataset.src;
                                    img.removeAttribute('data-src');
                                    this.observer.unobserve(img);
                                }
                            }
                        });
                    }, { rootMargin: '50px', threshold: 0.1 });
                }
            }
            observe(el) { if (this.observer && el) this.observer.observe(el); }
            disconnect() { if (this.observer) this.observer.disconnect(); }
        }

        const lazyLoader = new LazyLoadManager();

        // Application State
        class AppState {
            constructor() {
                this.mainImages = [];
                this.watermark = null;
                this.processedResults = [];
                this.undoStack = [];
                this.settings = {
                    // Image settings
                    count: 5,
                    opacity: 50,
                    size: 15,
                    rotation: 0,
                    mode: 'position',
                    position: 'top-left',
                    customPos: { x: 0.5, y: 0.5 }, // 0-1 percentages
                    blendMode: 'normal',
                    padding: 20,
                    // Text settings
                    textContent: '',
                    textSize: 24,
                    fontFamily: 'Arial',
                    textColor: '#ffffff',
                    textStroke: 2,
                    textStrokeColor: '#000000',
                    // Text Background
                    textBgEnabled: false,
                    textBgColor: '#000000',
                    textBgOpacity: 50,
                    textBgPadding: 10,
                    textBgRadius: 4,
                    // QR Settings
                    qrContent: '',
                    qrColor: '#000000',
                    qrBgColor: '#ffffff',
                    // Effects
                    shadowBlur: 0,
                    shadowOffset: 0,
                    shadowColor: '#000000',
                    brightness: 100,
                    contrast: 100,
                    saturation: 100,
                    // Output settings
                    outputQuality: 0.85, // 0-1 quality for JPEG/WEBP
                    preserveFormat: true // Keep original format when possible
                };
                this.theme = localStorage.getItem('theme') || 'light';
                this.previewMode = false;
                this.processing = false;
            }

            saveState() {
                this.undoStack.push({
                    settings: { ...this.settings },
                    timestamp: Date.now()
                });
                if (this.undoStack.length > 10) {
                    this.undoStack.shift();
                }
                this.updateUndoButton();
            }

            undoState() {
                if (this.undoStack.length > 0) {
                    const previousState = this.undoStack.pop();
                    this.settings = previousState.settings;
                    updateAllSliders();
                    this.updateUndoButton();
                    updatePreview();
                }
            }

            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) undoBtn.disabled = this.undoStack.length === 0;
            }
        }

        // Error Handler Class
        class ErrorHandler {
            static show(message, type = 'error', duration = 5000) {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert alert-${type}`;
                
                const icon = {
                    error: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>',
                    warning: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>',
                    success: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>',
                    info: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>'
                }[type] || '';

                alertDiv.innerHTML = `
                    <span style="display: flex; align-items: center; gap: 10px;">${icon} ${message}</span>
                    <button class="close-btn" onclick="this.parentElement.remove()" aria-label="Close">&times;</button>
                `;
                
                document.body.appendChild(alertDiv);
                
                if (duration > 0) {
                    setTimeout(() => {
                        if (alertDiv.parentElement) {
                            alertDiv.remove();
                        }
                    }, duration);
                }
                
                // Announce to screen readers
                this.announce(message);
            }

            static announce(message) {
                const announcement = document.createElement('div');
                announcement.setAttribute('aria-live', 'polite');
                announcement.setAttribute('aria-atomic', 'true');
                announcement.className = 'sr-only';
                announcement.textContent = message;
                document.body.appendChild(announcement);
                setTimeout(() => announcement.remove(), 1000);
            }
        }

        // File Validation
        class FileValidator {
            static validate(file, isWatermark = false) {
                if (!file || typeof file !== 'object') {
                    throw new Error('Invalid file');
                }

                // Security: Check file name for malicious patterns
                const dangerousExtensions = /\.(exe|bat|cmd|com|pif|scr|vbs|js|jar|php|asp|aspx)$/i;
                if (dangerousExtensions.test(file.name)) {
                    throw new Error('Security risk: This file type is not supported');
                }

                const maxSize = isWatermark ? CONFIG.MAX_WATERMARK_SIZE : CONFIG.MAX_FILE_SIZE;
                
                if (!CONFIG.SUPPORTED_FORMATS.includes(file.type)) {
                    throw new Error(`Unsupported file format: ${file.type.replace(/[<>]/g, '')}`);
                }
                
                if (file.size > maxSize) {
                    const maxSizeMB = Math.round(maxSize / (1024 * 1024));
                    throw new Error(`File size cannot exceed ${maxSizeMB}MB (Current: ${(file.size/(1024*1024)).toFixed(1)}MB)`);
                }
                
                if (file.size === 0) {
                    throw new Error('File is empty or corrupted');
                }
                
                return true;
            }

            static validateImage(img) {
                if (!img || !img.width || !img.height) {
                    throw new Error('Invalid image file');
                }

                // Check for minimum dimensions
                if (img.width < 10 || img.height < 10) {
                    throw new Error('Image is too small (min: 10x10 pixels)');
                }

                // Relaxed validation for very large images, just warn instead of error
                if (img.width > CONFIG.MAX_CANVAS_SIZE || img.height > CONFIG.MAX_CANVAS_SIZE) {
                    console.warn(`Image dimensions (${img.width}x${img.height}) exceed recommended limit. Processing may be slow.`);
                    ErrorHandler.show(
                        `Large image detected (${img.width}x${img.height}). Processing may be slow.`,
                        'warning',
                        4000
                    );
                }

                // Check aspect ratio for extreme values
                const aspectRatio = img.width / img.height;
                if (aspectRatio > 10 || aspectRatio < 0.1) {
                    console.warn(`Extreme aspect ratio: ${aspectRatio.toFixed(2)}`);
                    ErrorHandler.show(
                        'This image is very wide or very tall. Watermark may not display properly.',
                        'warning',
                        3000
                    );
                }

                return true;
            }

            static sanitizeFileName(filename) {
                // Remove or replace dangerous characters
                return filename.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_')
                              .substring(0, 255)  // Limit length
                              .trim();
            }

            static validateFileExtension(filename, allowedExtensions) {
                const ext = filename.toLowerCase().split('.').pop();
                return allowedExtensions.includes(ext);
            }
        }

        // Performance Manager - Enhanced
        class PerformanceManager {
            static optimizeCanvas(img) {
                const maxDimension = 2000;
                if (img.width <= maxDimension && img.height <= maxDimension) {
                    return { width: img.width, height: img.height, scale: 1 };
                }
                
                const scale = Math.min(maxDimension / img.width, maxDimension / img.height);
                return {
                    width: Math.round(img.width * scale),
                    height: Math.round(img.height * scale),
                    scale: scale
                };
            }

            static cleanup(canvas) {
                if (canvas && canvas.getContext) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    // Force garbage collection hint
                    canvas.width = canvas.height = 0;
                }
            }

            static formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            static measureTime(startTime) {
                return ((performance.now() - startTime) / 1000).toFixed(1);
            }

            // Advanced Performance Monitoring
            static getPerformanceLevel(processingTime, fileSize) {
                const ratio = processingTime / (fileSize / 1024 / 1024); // time per MB
                if (ratio < 0.5) return { level: 'fast', color: 'var(--success)', badge: 'FAST' };
                if (ratio < 2) return { level: 'medium', color: 'var(--warning)', badge: 'MEDIUM' };
                return { level: 'slow', color: 'var(--error)', badge: 'SLOW' };
            }

            // Memory usage estimation
            static estimateMemoryUsage(images) {
                return images.reduce((total, img) => {
                    return total + (img.img.width * img.img.height * 4); // RGBA
                }, 0);
            }

            // Image compression before processing
            static async compressImage(canvas, quality = 0.8) {
                return new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/jpeg', quality);
                });
            }

            // Batch processing with concurrency control
            static async processBatch(items, processor, concurrency = 3) {
                const results = [];
                for (let i = 0; i < items.length; i += concurrency) {
                    const batch = items.slice(i, i + concurrency);
                    const batchResults = await Promise.all(
                        batch.map(item => processor(item))
                    );
                    results.push(...batchResults);
                    
                    // Small delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                return results;
            }

            // Progressive canvas rendering for large images
            static renderProgressive(canvas, img, onProgress) {
                const ctx = canvas.getContext('2d');
                const chunkSize = 500; // pixels
                let y = 0;
                
                function renderChunk() {
                    const height = Math.min(chunkSize, img.height - y);
                    if (height <= 0) {
                        onProgress(100);
                        return;
                    }
                    
                    ctx.drawImage(img, 0, y, img.width, height, 0, y, canvas.width, height);
                    y += height;
                    
                    const progress = (y / img.height) * 100;
                    onProgress(progress);
                    
                    if (y < img.height) {
                        requestAnimationFrame(renderChunk);
                    }
                }
                
                requestAnimationFrame(renderChunk);
            }
        }

        // Initialize application state
        const appState = new AppState();

        // DOM Elements
        const elements = {
            mainImageBox: document.getElementById('mainImageBox'),
            watermarkBox: document.getElementById('watermarkBox'),
            mainImageInput: document.getElementById('mainImageInput'),
            watermarkInput: document.getElementById('watermarkInput'),
            mainGallery: document.getElementById('mainGallery'),
            previewSection: document.getElementById('previewSection'),
            previewCanvas: document.getElementById('previewCanvas'),
            previewInfo: document.getElementById('previewInfo'),
            processBtn: document.getElementById('processBtn'),
            previewBtn: document.getElementById('previewBtn'),
            undoBtn: document.getElementById('undoBtn'),
            progressBar: document.getElementById('progressBar'),
            progressFill: document.getElementById('progressFill'),
            resultsSection: document.getElementById('resultsSection'),
            resultsGrid: document.getElementById('resultsGrid'),
            stats: document.getElementById('stats'),
            positionGrid: document.getElementById('positionGrid'),
            keyboardShortcuts: document.getElementById('keyboardShortcuts')
        };

        // Theme Management
        function toggleTheme() {
            appState.theme = appState.theme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', appState.theme);
            localStorage.setItem('theme', appState.theme);
            
            const themeBtn = document.querySelector('.theme-toggle');
            themeBtn.innerHTML = appState.theme === 'light' ? 
                '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> Dark Mode' : 
                '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg> Light Mode';
            
            ErrorHandler.show(
                `${appState.theme === 'light' ? 'Light' : 'Dark'} theme activated`,
                'success',
                2000
            );
        }

        // Initialize theme
        function initializeTheme() {
            document.documentElement.setAttribute('data-theme', appState.theme);
            const themeBtn = document.querySelector('.theme-toggle');
            themeBtn.innerHTML = appState.theme === 'light' ? 
                '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> Dark Mode' : 
                '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg> Light Mode';
        }

        // Tab Management
        function switchTab(tabName) {
            // Update buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-selected', 'false');
            });
            document.getElementById(`${tabName}-tab-btn`).classList.add('active');
            document.getElementById(`${tabName}-tab-btn`).setAttribute('aria-selected', 'true');
            
            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            appState.saveState();
        }

        // Drag and Drop Handlers
        function setupDragAndDrop() {
            const boxes = [elements.mainImageBox, elements.watermarkBox];
            
            boxes.forEach(box => {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    box.addEventListener(eventName, preventDefaults, false);
                });
                
                ['dragenter', 'dragover'].forEach(eventName => {
                    box.addEventListener(eventName, () => box.classList.add('dragover'), false);
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    box.addEventListener(eventName, () => box.classList.remove('dragover'), false);
                });
            });
            
            elements.mainImageBox.addEventListener('drop', handleMainImageDrop, false);
            elements.watermarkBox.addEventListener('drop', handleWatermarkDrop, false);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleMainImageDrop(e) {
            const files = Array.from(e.dataTransfer.files).filter(file =>
                CONFIG.SUPPORTED_FORMATS.includes(file.type)
            );
            files.forEach(file => loadImage(file, 'main'));
        }

        function handleWatermarkDrop(e) {
            const file = e.dataTransfer.files[0];
            if (file && CONFIG.SUPPORTED_FORMATS.includes(file.type)) {
                loadImage(file, 'watermark');
            }
        }

        // Click Handlers
        function setupClickHandlers() {
            elements.mainImageBox.addEventListener('click', () => {
                elements.mainImageInput.click();
            });
            
            elements.watermarkBox.addEventListener('click', () => {
                elements.watermarkInput.click();
            });
            
            // Keyboard support
            elements.mainImageBox.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    elements.mainImageInput.click();
                }
            });
            
            elements.watermarkBox.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    elements.watermarkInput.click();
                }
            });
        }

        // File Input Handlers
        function setupFileInputs() {
            elements.mainImageInput.addEventListener('change', (e) => {
                Array.from(e.target.files).forEach(file => loadImage(file, 'main'));
            });
            
            elements.watermarkInput.addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    loadImage(e.target.files[0], 'watermark');
                }
            });
        }

        // Image Loading
        async function loadImage(file, type) {
            try {
                FileValidator.validate(file, type === 'watermark');
                
                const startTime = performance.now();
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            try {
                                FileValidator.validateImage(img);
                                
                                if (type === 'main') {
                                    // Backup original watermark when first main image is loaded
                                    if (!appState.uploadedWatermark && appState.watermark) {
                                        appState.uploadedWatermark = appState.watermark;
                                    }
                                    
                                    appState.mainImages.push({
                                        img,
                                        name: file.name,
                                        size: file.size,
                                        lastModified: file.lastModified
                                    });
                                    updateMainGallery();
                                    updateProcessButtons();
                                    
                                    const loadTime = PerformanceManager.measureTime(startTime);
                                    ErrorHandler.show(
                                        `${file.name} loaded (${loadTime}s)`,
                                        'success',
                                        3000
                                    );
                                } else {
                                    // Store original watermark for QR restore functionality
                                    if (appState.watermark && !appState.uploadedWatermark) {
                                        appState.uploadedWatermark = appState.watermark;
                                        document.getElementById('restoreWatermarkBtn').style.display = 'block';
                                    }
                                    
                                    appState.watermark = img;
                                    updateWatermarkDisplay(img, file);
                                    updateProcessButtons();
                                    
                                    const loadTime = PerformanceManager.measureTime(startTime);
                                    ErrorHandler.show(
                                        `Watermark loaded (${loadTime}s)`,
                                        'success',
                                        3000
                                    );
                                }
                                
                                updatePreview();
                                resolve();
                            } catch (error) {
                                ErrorHandler.show('Image loading error: ' + error.message);
                                reject(error);
                            }
                        };
                        img.onerror = (e) => {
                            const error = new Error('Image could not be loaded. Please check if the file is corrupted.');
                            ErrorHandler.show(error.message);
                            reject(error);
                        };
                        img.src = e.target.result;
                    };
                    reader.onerror = (e) => {
                        const error = new Error('File could not be read. Please try again.');
                        ErrorHandler.show(error.message);
                        reject(error);
                    };
                    reader.readAsDataURL(file);
                });
                
            } catch (error) {
                ErrorHandler.show('File loading error: ' + error.message);
                throw error;
            }
        }

        // Update Main Gallery
        function updateMainGallery() {
            const gallery = elements.mainGallery;
            const box = elements.mainImageBox;
            
            if (appState.mainImages.length > 0) {
                box.classList.add('has-image');
                
                // Safely escape HTML content
                const escapeHtml = (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };

                gallery.innerHTML = appState.mainImages.map((item, index) => `
                    <div class="gallery-item" role="listitem">
                        <img src="${item.img.src}" alt="${escapeHtml(item.name)}" loading="lazy" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyIDJMMTMuMDkgOC4yNkwyMiA5TDE3IDE0TDE4LjE4IDIxTDEyIDE4TDUuODIgMjFMNyAxNEwyIDlMMTAuOTEgOC4yNkwxMiAyWiIgZmlsbD0iI2NjYyIvPgo8L3N2Zz4='; this.alt='Image could not be loaded';">
                        <button class="remove-btn" onclick="removeImage(${index})" aria-label="Remove ${escapeHtml(item.name)}">√ó</button>
                    </div>
                `).join('');
                
                // Show clear button
                const clearBtn = document.getElementById('clearImagesBtn');
                if (clearBtn) clearBtn.style.display = 'block';
                
                // Update file info
                const totalSize = appState.mainImages.reduce((sum, item) => sum + item.size, 0);
                let fileInfo = box.querySelector('.file-info');
                if (!fileInfo) {
                    fileInfo = document.createElement('div');
                    fileInfo.className = 'file-info';
                    box.appendChild(fileInfo);
                }
                
                fileInfo.innerHTML = `
                    <strong>${appState.mainImages.length}</strong> images loaded
                    (<strong>${PerformanceManager.formatFileSize(totalSize)}</strong>)
                    ${appState.mainImages.length > 10 ? '<br><small style="color: var(--warning);">‚ö†Ô∏è Many images - processing may be slow</small>' : ''}
                `;
            } else {
                box.classList.remove('has-image');
                gallery.innerHTML = '';
                const clearBtn = document.getElementById('clearImagesBtn');
                if (clearBtn) clearBtn.style.display = 'none';
                const fileInfo = box.querySelector('.file-info');
                if (fileInfo) fileInfo.remove();
            }
        }

        // Update Watermark Display
        function updateWatermarkDisplay(img, file) {
            const box = elements.watermarkBox;
            
            // Safely escape HTML content
            const escapeHtml = (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };

            const sanitizedFileName = FileValidator.sanitizeFileName(file.name);
            
            box.innerHTML = `
                <img src="${img.src}" alt="Watermark preview" style="max-height: 150px; margin-bottom: 15px; border-radius: 8px; box-shadow: 0 2px 8px var(--shadow);" onerror="this.style.display='none'; this.nextElementSibling.textContent='Watermark preview could not be loaded'">
                <p style="color: var(--success); font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Watermark loaded
                </p>
                <div class="file-info enhanced">
                    <div>
                        <strong>${escapeHtml(sanitizedFileName)}</strong><br>
                        <div class="file-specs">
                            <small>${PerformanceManager.formatFileSize(file.size)} ‚Ä¢ ${img.width}√ó${img.height}px</small>
                            ${img.width / img.height > 3 || img.height / img.width > 3 ? '<br><small style="color: var(--warning);">‚ö†Ô∏è Extreme aspect ratio</small>' : ''}
                        </div>
                    </div>
                    ${file.type === 'image/png' ? '<span class="perf-badge" style="background: var(--success); color: white; font-size: 0.7rem; padding: 2px 6px; border-radius: 4px;">PNG</span>' : ''}
                </div>
            `;
            box.classList.add('has-image');
        }

        // Remove Image
        function removeImage(index) {
            const removedImage = appState.mainImages[index];
            appState.mainImages.splice(index, 1);
            updateMainGallery();
            updateProcessButtons();
            updatePreview();
            
            ErrorHandler.show(
                `${removedImage.name} removed`,
                'info',
                3000
            );
        }

        // Update Process Buttons
        function updateProcessButtons() {
            const hasImages = appState.mainImages.length > 0;
            const hasWatermark = appState.watermark !== null || appState.settings.textContent.trim() !== '';
            const canProcess = hasImages && hasWatermark && !appState.processing;
            
            elements.processBtn.disabled = !canProcess;
            elements.previewBtn.disabled = !canProcess;
            
            if (hasImages) {
                elements.stats.style.display = 'flex';
                document.getElementById('totalImages').textContent = appState.mainImages.length;
                
                const totalSize = appState.mainImages.reduce((sum, item) => sum + item.size, 0);
                document.getElementById('totalSize').textContent =
                    (totalSize / (1024 * 1024)).toFixed(1);
            } else {
                elements.stats.style.display = 'none';
            }
        }

        // Settings Management
        function setupSettings() {
            const sliders = [
                { id: 'countSlider', value: 'countValue', setting: 'count' },
                { id: 'opacitySlider', value: 'opacityValue', setting: 'opacity' },
                { id: 'sizeSlider', value: 'sizeValue', setting: 'size' },
                { id: 'rotationSlider', value: 'rotationValue', setting: 'rotation' },
                { id: 'paddingSlider', value: 'paddingValue', setting: 'padding' },
                { id: 'qualitySlider', value: 'qualityValue', setting: 'outputQuality', multiplier: 0.01 },
                { id: 'textSizeSlider', value: 'textSizeValue', setting: 'textSize' },
                { id: 'textStrokeSlider', value: 'textStrokeValue', setting: 'textStroke' },
                { id: 'textBgOpacitySlider', value: 'textBgOpacityValue', setting: 'textBgOpacity' },
                { id: 'textBgPaddingSlider', value: 'textBgPaddingValue', setting: 'textBgPadding' },
                { id: 'textBgRadiusSlider', value: 'textBgRadiusValue', setting: 'textBgRadius' },
                { id: 'shadowBlurSlider', value: 'shadowBlurValue', setting: 'shadowBlur' },
                { id: 'shadowOffsetSlider', value: 'shadowOffsetValue', setting: 'shadowOffset' },
                { id: 'brightnessSlider', value: 'brightnessValue', setting: 'brightness' },
                { id: 'contrastSlider', value: 'contrastValue', setting: 'contrast' },
                { id: 'saturationSlider', value: 'saturationValue', setting: 'saturation' }
            ];

            sliders.forEach(({ id, value, setting, multiplier }) => {
                const slider = document.getElementById(id);
                const valueSpan = document.getElementById(value);
                
                if (slider && valueSpan) {
                    slider.addEventListener('input', (e) => {
                        const rawVal = parseInt(e.target.value);
                        const val = multiplier ? rawVal * multiplier : rawVal;
                        appState.settings[setting] = val;
                        const suffix = setting === 'rotation' ? '¬∞' :
                                      (setting === 'opacity' || setting.includes('Opacity') || setting.includes('brightness') || setting.includes('contrast') || setting.includes('saturation')) ? '%' :
                                      setting.includes('Size') ? 'px' :
                                      setting.includes('padding') || setting.includes('Padding') || setting.includes('Blur') || setting.includes('Offset') || setting.includes('Stroke') || setting.includes('Radius') ? 'px' : '';
                        valueSpan.textContent = val + suffix;
                        updatePreview();
                        appState.saveState();
                    });
                }
            });

            // Checkbox inputs
            const checkboxes = [
                { id: 'textBgEnabled', setting: 'textBgEnabled' },
                { id: 'preserveFormat', setting: 'preserveFormat' }
            ];
            
            checkboxes.forEach(({ id, setting }) => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', (e) => {
                        appState.settings[setting] = e.target.checked;
                        updatePreview();
                        appState.saveState();
                    });
                }
            });

            // Text inputs
            const textContent = document.getElementById('textContent');
            if (textContent) {
                textContent.addEventListener('input', (e) => {
                    appState.settings.textContent = e.target.value;
                    updatePreview();
                    updateProcessButtons();
                });
            }
            
            // QR inputs
            const qrContent = document.getElementById('qrContent');
            if (qrContent) {
                qrContent.addEventListener('input', (e) => {
                    appState.settings.qrContent = e.target.value;
                });
            }

            // Select inputs
            const selects = ['blendMode', 'fontFamily'];
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.addEventListener('change', (e) => {
                        appState.settings[selectId] = e.target.value;
                        updatePreview();
                        appState.saveState();
                    });
                }
            });

            // Color inputs
            const colors = [
                { id: 'textColor', value: 'textColorValue', setting: 'textColor' },
                { id: 'textStrokeColor', value: 'textStrokeColorValue', setting: 'textStrokeColor' },
                { id: 'textBgColor', value: 'textBgColorValue', setting: 'textBgColor' },
                { id: 'qrColor', value: 'qrColorValue', setting: 'qrColor' },
                { id: 'qrBgColor', value: 'qrBgColorValue', setting: 'qrBgColor' },
                { id: 'shadowColor', value: 'shadowColorValue', setting: 'shadowColor' }
            ];

            colors.forEach(({ id, value, setting }) => {
                const colorInput = document.getElementById(id);
                const valueSpan = document.getElementById(value);
                
                if (colorInput && valueSpan) {
                    colorInput.addEventListener('input', (e) => {
                        appState.settings[setting] = e.target.value;
                        valueSpan.textContent = e.target.value;
                        updatePreview();
                        appState.saveState();
                    });
                }
            });
        }

        // QR Code Management
        function generateAndSetQR() {
            const content = appState.settings.qrContent;
            if (!content) {
                ErrorHandler.show('Please enter text or URL for the QR code', 'warning');
                return;
            }
            
            // Create temporary container
            const tempDiv = document.createElement('div');
            
            // Generate QR
            try {
                new QRCode(tempDiv, {
                    text: content,
                    width: 512,
                    height: 512,
                    colorDark: appState.settings.qrColor,
                    colorLight: appState.settings.qrBgColor,
                    correctLevel: QRCode.CorrectLevel.H
                });
                
                // Wait for QR code to be generated (it's usually canvas or img)
                setTimeout(() => {
                    const canvas = tempDiv.querySelector('canvas');
                    const img = tempDiv.querySelector('img');
                    const src = canvas ? canvas.toDataURL() : (img ? img.src : null);
                    
                    if (src) {
                        const qrImage = new Image();
                        qrImage.onload = () => {
                            // Save original watermark if not saved yet
                            if (!appState.uploadedWatermark && appState.watermark) {
                                appState.uploadedWatermark = appState.watermark;
                                document.getElementById('restoreWatermarkBtn').style.display = 'block';
                            } else if (!appState.uploadedWatermark) {
                                // If no watermark was uploaded, we don't show restore button yet, 
                                // but we set this as the "uploaded" one effectively for logic consistency? 
                                // No, better to track explicitly.
                            }
                            
                            appState.watermark = qrImage;
                            updatePreview();
                            updateProcessButtons();
                            
                            // Show preview in panel
                            const previewContainer = document.getElementById('qrPreviewContainer');
                            previewContainer.innerHTML = '';
                            const previewImg = new Image();
                            previewImg.src = src;
                            previewImg.style.width = '150px';
                            previewImg.style.border = '2px solid var(--border)';
                            previewImg.style.borderRadius = '8px';
                            previewContainer.appendChild(previewImg);
                            
                            ErrorHandler.show('QR Code generated and set as watermark!', 'success');
                        };
                        qrImage.src = src;
                    } else {
                        ErrorHandler.show('Failed to generate QR code image', 'error');
                    }
                }, 100);
                
            } catch (e) {
                console.error(e);
                ErrorHandler.show('Error generating QR code: ' + e.message, 'error');
            }
        }
        
        function restoreUploadedWatermark() {
            if (appState.uploadedWatermark) {
                appState.watermark = appState.uploadedWatermark;
                updatePreview();
                updateProcessButtons();
                document.getElementById('restoreWatermarkBtn').style.display = 'none';
                appState.uploadedWatermark = null; // Clear backup
                ErrorHandler.show('Original watermark restored', 'success');
            }
        }

        // Mode Management
        function setMode(mode, element = null) {
            appState.settings.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });
            
            // Use passed element or find by mode value
            const activeBtn = element || document.querySelector(`[onclick*="'${mode}'"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.setAttribute('aria-pressed', 'true');
            }
            
            elements.positionGrid.style.display = mode === 'position' ? 'grid' : 'none';
            updatePreview();
            appState.saveState();
        }

        function setPosition(position, element = null) {
            appState.settings.position = position;
            document.querySelectorAll('.position-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });
            
            // Use passed element or find by position value
            const activeBtn = element || document.querySelector(`[onclick*="'${position}'"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.setAttribute('aria-pressed', 'true');
            }
            updatePreview();
            appState.saveState();
        }

        // Preview System
        function updatePreview() {
            if (appState.mainImages.length === 0) {
                elements.previewSection.style.display = 'none';
                return;
            }

            const firstImage = appState.mainImages[0];
            if (!firstImage) return;

            elements.previewSection.style.display = 'block';
            
            const canvas = elements.previewCanvas;
            const ctx = canvas.getContext('2d');
            
            // Optimize canvas size for preview
            const optimized = PerformanceManager.optimizeCanvas(firstImage.img);
            canvas.width = optimized.width;
            canvas.height = optimized.height;
            
            // Clear and draw image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(firstImage.img, 0, 0, canvas.width, canvas.height);
            
            // Simply draw watermarks on top of the image
            drawWatermarks(ctx, canvas.width, canvas.height);
            
            // Update preview info
            elements.previewInfo.innerHTML = `
                <strong>Preview:</strong> ${firstImage.name}<br>
                <strong>Size:</strong> ${canvas.width}√ó${canvas.height}px<br>
                <strong>Mode:</strong> ${appState.settings.mode}<br>
                <strong>Watermark count:</strong> ${appState.settings.mode === 'position' ? 1 : appState.settings.count}
            `;
        }

        function previewSingle() {
            if (appState.mainImages.length > 0) {
                updatePreview();
                elements.previewSection.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // Watermark Drawing
        function drawWatermarks(ctx, canvasWidth, canvasHeight) {
            const hasImageWatermark = appState.watermark !== null;
            const hasTextWatermark = appState.settings.textContent.trim() !== '';
            
            if (!hasImageWatermark && !hasTextWatermark) return;

            ctx.save();
            ctx.globalAlpha = appState.settings.opacity / 100;
            ctx.globalCompositeOperation = appState.settings.blendMode;

            if (appState.settings.mode === 'position') {
                const pos = getWatermarkPosition(canvasWidth, canvasHeight);
                drawSingleWatermark(ctx, pos.x, pos.y, canvasWidth, canvasHeight);
            } else if (appState.settings.mode === 'random') {
                for (let i = 0; i < appState.settings.count; i++) {
                    const x = Math.random() * canvasWidth * 0.8;
                    const y = Math.random() * canvasHeight * 0.8;
                    drawSingleWatermark(ctx, x, y, canvasWidth, canvasHeight);
                }
            } else if (appState.settings.mode === 'grid') {
                drawGridWatermarks(ctx, canvasWidth, canvasHeight);
            } else if (appState.settings.mode === 'pattern') {
                drawPatternWatermarks(ctx, canvasWidth, canvasHeight);
            }

            ctx.restore();
        }

        function drawSingleWatermark(ctx, x, y, canvasWidth, canvasHeight) {
            ctx.save();
            
            // Apply shadow
            if (appState.settings.shadowBlur > 0) {
                ctx.shadowColor = appState.settings.shadowColor;
                ctx.shadowBlur = appState.settings.shadowBlur;
                ctx.shadowOffsetX = appState.settings.shadowOffset;
                ctx.shadowOffsetY = appState.settings.shadowOffset;
            }

            const rotation = (appState.settings.rotation * Math.PI) / 180;
            
            // Draw image watermark
            if (appState.watermark) {
                const size = Math.min(canvasWidth, canvasHeight) * (appState.settings.size / 100);
                const wmWidth = size;
                const wmHeight = (appState.watermark.height / appState.watermark.width) * size;
                
                ctx.translate(x + wmWidth / 2, y + wmHeight / 2);
                ctx.rotate(rotation);
                ctx.drawImage(appState.watermark, -wmWidth / 2, -wmHeight / 2, wmWidth, wmHeight);
                ctx.rotate(-rotation);
                ctx.translate(-(x + wmWidth / 2), -(y + wmHeight / 2));
            }
            
            // Draw text watermark
            if (appState.settings.textContent.trim()) {
                const fontSize = appState.settings.textSize;
                ctx.font = `${fontSize}px ${appState.settings.fontFamily}`;
                
                // Calculate metrics for background
                const metrics = ctx.measureText(appState.settings.textContent);
                const textWidth = metrics.width;
                const textHeight = fontSize; // Approximation
                
                // Align text with image if both exist, otherwise use raw position
                const textX = x + (appState.watermark ? 0 : 0);
                const textY = y + (appState.watermark ? 0 : 0);
                
                ctx.translate(textX, textY);
                ctx.rotate(rotation);
                
                // Draw Background if enabled
                if (appState.settings.textBgEnabled) {
                    const pad = appState.settings.textBgPadding;
                    const radius = appState.settings.textBgRadius;
                    const bgX = -pad; // since we are drawing text at 0,0 (translated)
                    const bgY = 0; // textBaseline is top
                    const bgWidth = textWidth + (pad * 2);
                    const bgHeight = textHeight + (pad * 2);
                    
                    ctx.save();
                    ctx.fillStyle = appState.settings.textBgColor;
                    ctx.globalAlpha = (appState.settings.opacity / 100) * (appState.settings.textBgOpacity / 100);
                    
                    // Draw rounded rect
                    ctx.beginPath();
                    ctx.moveTo(bgX + radius, bgY);
                    ctx.lineTo(bgX + bgWidth - radius, bgY);
                    ctx.quadraticCurveTo(bgX + bgWidth, bgY, bgX + bgWidth, bgY + radius);
                    ctx.lineTo(bgX + bgWidth, bgY + bgHeight - radius);
                    ctx.quadraticCurveTo(bgX + bgWidth, bgY + bgHeight, bgX + bgWidth - radius, bgY + bgHeight);
                    ctx.lineTo(bgX + radius, bgY + bgHeight);
                    ctx.quadraticCurveTo(bgX, bgY + bgHeight, bgX, bgY + bgHeight - radius);
                    ctx.lineTo(bgX, bgY + radius);
                    ctx.quadraticCurveTo(bgX, bgY, bgX + radius, bgY);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                }

                ctx.fillStyle = appState.settings.textColor;
                ctx.strokeStyle = appState.settings.textStrokeColor;
                ctx.lineWidth = appState.settings.textStroke;
                ctx.textBaseline = 'top';
                
                // Adjust text position to be inside the padding
                const drawX = appState.settings.textBgEnabled ? 0 : 0;
                const drawY = appState.settings.textBgEnabled ? appState.settings.textBgPadding : 0;
                
                if (appState.settings.textStroke > 0) {
                    ctx.strokeText(appState.settings.textContent, drawX, drawY);
                }
                ctx.fillText(appState.settings.textContent, drawX, drawY);
                
                ctx.rotate(-rotation);
                ctx.translate(-textX, -textY);
            }
            
            ctx.restore();
        }

        function drawGridWatermarks(ctx, canvasWidth, canvasHeight) {
            // Use a more robust grid calculation that covers the whole image
            const total = appState.settings.count;
            const aspectRatio = canvasWidth / canvasHeight;
            
            let cols = Math.ceil(Math.sqrt(total * aspectRatio));
            let rows = Math.ceil(total / cols);
            
            // Adjust if we need more rows to fit count
            if (cols * rows < total) rows++;

            const spacingX = canvasWidth / (cols + 1);
            const spacingY = canvasHeight / (rows + 1);

            let count = 0;
            for (let row = 0; row < rows && count < total; row++) {
                for (let col = 0; col < cols && count < total; col++) {
                    const x = spacingX * (col + 1);
                    const y = spacingY * (row + 1);
                    drawSingleWatermark(ctx, x, y, canvasWidth, canvasHeight);
                    count++;
                }
            }
        }

        function drawPatternWatermarks(ctx, canvasWidth, canvasHeight) {
            const spacing = Math.min(canvasWidth, canvasHeight) / 4;
            for (let x = spacing; x < canvasWidth; x += spacing) {
                for (let y = spacing; y < canvasHeight; y += spacing) {
                    drawSingleWatermark(ctx, x - spacing/2, y - spacing/2, canvasWidth, canvasHeight);
                }
            }
        }

        function getWatermarkPosition(canvasWidth, canvasHeight) {
            const padding = appState.settings.padding;
            const size = Math.min(canvasWidth, canvasHeight) * (appState.settings.size / 100);
            
            if (appState.settings.position === 'custom') {
                 return {
                    x: canvasWidth * appState.settings.customPos.x,
                    y: canvasHeight * appState.settings.customPos.y
                };
            }
            
            const positions = {
                'top-left': { x: padding, y: padding },
                'top-center': { x: (canvasWidth - size) / 2, y: padding },
                'top-right': { x: canvasWidth - size - padding, y: padding },
                'left-center': { x: padding, y: (canvasHeight - size) / 2 },
                'center': { x: (canvasWidth - size) / 2, y: (canvasHeight - size) / 2 },
                'right-center': { x: canvasWidth - size - padding, y: (canvasHeight - size) / 2 },
                'bottom-left': { x: padding, y: canvasHeight - size - padding },
                'bottom-center': { x: (canvasWidth - size) / 2, y: canvasHeight - size - padding },
                'bottom-right': { x: canvasWidth - size - padding, y: canvasHeight - size - padding }
            };
            
            return positions[appState.settings.position] || positions['top-left'];
        }

        // Main Processing
        async function processAllImages() {
            if (appState.processing) return;
            
            appState.processing = true;
            appState.processedResults = [];
            elements.resultsGrid.innerHTML = '';
            
            const progressBar = elements.progressBar;
            const progressFill = elements.progressFill;
            const processedCounter = document.getElementById('processedImages');
            const timeCounter = document.getElementById('processingTime');
            
            // Reset progress bar to 0% at start
            progressFill.style.width = '0%';
            progressFill.textContent = '0%';
            processedCounter.textContent = '0';
            timeCounter.textContent = '0.0';
            
            progressBar.style.display = 'block';
            elements.processBtn.disabled = true;
            
            const startTime = performance.now();
            
            const totalImages = appState.mainImages.length;
            const batchSize = totalImages > 20 ? 4 : (totalImages > 10 ? 3 : 2);
            let processedCount = 0;
            
            try {
                // Process images in parallel batches for speed
                for (let i = 0; i < totalImages; i += batchSize) {
                    const batch = appState.mainImages.slice(i, Math.min(i + batchSize, totalImages));
                    
                    // Process batch in parallel
                    const batchResults = await Promise.all(
                        batch.map(imageData => processImage(imageData))
                    );
                    
                    // Add results and update UI
                    batchResults.forEach((result, idx) => {
                        appState.processedResults.push(result);
                        addResultToGrid(result, processedCount + idx);
                    });
                    
                    processedCount += batchResults.length;
                    
                    // Update progress
                    const progress = Math.round((processedCount / totalImages) * 100);
                    progressFill.style.width = progress + '%';
                    progressFill.textContent = progress + '%';
                    processedCounter.textContent = processedCount;
                    
                    const totalTime = PerformanceManager.measureTime(startTime);
                    timeCounter.textContent = totalTime;
                    
                    // Small yield for UI responsiveness
                    await new Promise(resolve => requestAnimationFrame(resolve));
                }
                
                const finalTime = PerformanceManager.measureTime(startTime);
                const avgTime = (parseFloat(finalTime) / totalImages).toFixed(2);
                
                ErrorHandler.show(
                    `${totalImages} images processed in ${finalTime}s (avg: ${avgTime}s/image)`,
                    'success'
                );
                
            } catch (error) {
                ErrorHandler.show(`Processing error: ${error.message}`);
            } finally {
                progressBar.style.display = 'none';
                elements.processBtn.disabled = false;
                elements.resultsSection.style.display = 'block';
                appState.processing = false;
            }
        }

        async function processImage(imageData) {
            try {
                // Check cache first
                const cacheKey = `${imageData.name}_${imageData.lastModified}_${JSON.stringify(appState.settings)}`;
                const cached = imageCache.get(cacheKey);
                if (cached) {
                    return cached;
                }

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                if (!ctx) {
                    throw new Error('Canvas context could not be created');
                }
                
                canvas.width = imageData.img.width;
                canvas.height = imageData.img.height;
                
                // Draw original image
                ctx.drawImage(imageData.img, 0, 0);
                
                // Draw watermarks on top
                drawWatermarks(ctx, canvas.width, canvas.height);
                
                // Determine output format
                const originalExt = imageData.name.toLowerCase().split('.').pop();
                let outputFormat = 'image/jpeg';
                let outputQuality = appState.settings.outputQuality;
                
                if (appState.settings.preserveFormat) {
                    if (originalExt === 'png') outputFormat = 'image/png';
                    else if (originalExt === 'webp') outputFormat = 'image/webp';
                }
                
                // For JPEG, fill background with white
                let exportCanvas = canvas;
                if (outputFormat === 'image/jpeg') {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    tempCtx.fillStyle = '#FFFFFF';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(canvas, 0, 0);
                    exportCanvas = tempCanvas;
                }
                
                // Use ProgressiveExporter with toBlob() for better memory management
                const exported = await ProgressiveExporter.exportImage(exportCanvas, outputFormat, outputQuality);
                
                const result = {
                    dataURL: exported.dataURL,
                    blob: exported.blob,
                    originalName: imageData.name,
                    name: imageData.name,
                    size: exported.size,
                    timestamp: Date.now()
                };
                
                // Cache the result
                imageCache.set(cacheKey, result);
                
                // Cleanup
                PerformanceManager.cleanup(canvas);
                if (exportCanvas !== canvas) PerformanceManager.cleanup(exportCanvas);
                
                return result;
            } catch (error) {
                ErrorHandler.show('Image processing error: ' + error.message);
                throw error;
            }
        }

        function addResultToGrid(result, index) {
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            
            // Performance badge
            let perfBadge = '';
            if (result.performanceMetrics) {
                const { perfLevel } = result.performanceMetrics;
                perfBadge = `<span class="perf-badge ${perfLevel.level}" style="background: ${perfLevel.color}">${perfLevel.badge}</span>`;
            }
            
            resultItem.innerHTML = `
                <img src="${result.dataURL}" alt="${result.name}" loading="lazy">
                <div class="file-name">
                    ${result.name}
                    ${perfBadge}
                </div>
                <div class="file-size">
                    Size: ~${PerformanceManager.formatFileSize(result.dataURL.length * 0.75)}
                    ${result.performanceMetrics ? `‚Ä¢ ${result.performanceMetrics.processingTime}s` : ''}
                </div>
                <div class="download-btns">
                    <button class="download-btn png" onclick="downloadSingle(${index}, 'png')">PNG</button>
                    <button class="download-btn jpg" onclick="downloadSingle(${index}, 'jpg')">JPG</button>
                    <button class="download-btn webp" onclick="downloadSingle(${index}, 'webp')">WEBP</button>
                </div>
            `;
            elements.resultsGrid.appendChild(resultItem);
        }

        // Download Functions
        function downloadSingle(index, format) {
            const result = appState.processedResults[index];
            const link = document.createElement('a');
            const fileName = result.originalName.replace(/\.[^/.]+$/, '');
            
            let dataURL;
            if (format === 'png') {
                dataURL = result.dataURL;
            } else {
                // For JPG and WEBP, recreate the canvas from the PNG dataURL
                const tempImg = new Image();
                tempImg.onload = function() {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCanvas.width = tempImg.width;
                    tempCanvas.height = tempImg.height;
                    
                    if (format === 'jpg') {
                        // Fill with white background for JPG
                        tempCtx.fillStyle = '#FFFFFF';
                        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    }
                    
                    // Draw the image
                    tempCtx.drawImage(tempImg, 0, 0);
                    
                    // Generate the appropriate format
                    if (format === 'jpg') {
                        dataURL = tempCanvas.toDataURL('image/jpeg', appState.settings.outputQuality);
                    } else if (format === 'webp') {
                        dataURL = tempCanvas.toDataURL('image/webp', appState.settings.outputQuality);
                    }
                    
                    // Download the file
                    link.download = `${fileName}.${format}`;
                    link.href = dataURL;
                    link.click();
                    
                    PerformanceManager.cleanup(tempCanvas);
                    ErrorHandler.show(`${result.name} downloaded`, 'success', 2000);
                };
                
                tempImg.src = result.dataURL;
                return; // Exit early for async processing
            }
            
            link.download = `${fileName}.${format}`;
            link.href = dataURL;
            link.click();
            
            ErrorHandler.show(`${result.name} downloaded`, 'success', 2000);
        }

        async function downloadAllImages() {
            if (!window.JSZip) {
                ErrorHandler.show('ZIP functionality could not be loaded');
                return;
            }
            
            const zip = new JSZip();
            const folder = zip.folder('watermarked_images');
            
            appState.processedResults.forEach((result) => {
                const base64Data = result.dataURL.split(',')[1];
                folder.file(result.name, base64Data, { base64: true });
            });
            
            try {
                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `watermarked_images_${new Date().getTime()}.zip`;
                link.click();
                
                ErrorHandler.show('ZIP file downloaded', 'success');
            } catch (error) {
                ErrorHandler.show('Could not create ZIP: ' + error.message);
            }
        }

        function clearResults() {
            appState.processedResults = [];
            elements.resultsGrid.innerHTML = '';
            elements.resultsSection.style.display = 'none';
            
            ErrorHandler.show('Results cleared', 'info');
        }

        function shareResults() {
            if (navigator.share && appState.processedResults.length > 0) {
                navigator.share({
                    title: 'Watermark Application Results',
                    text: `${appState.processedResults.length} images processed with watermark`,
                    url: window.location.href
                }).then(() => {
                    ErrorHandler.show('Shared', 'success');
                }).catch(() => {
                    copyToClipboard();
                });
            } else {
                copyToClipboard();
            }
        }

        function copyToClipboard() {
            navigator.clipboard.writeText(window.location.href).then(() => {
                ErrorHandler.show('Link copied to clipboard', 'success');
            });
        }

        // Preset Management
        function savePreset() {
            const modal = document.createElement('div');
            modal.className = 'loading-overlay';
            modal.innerHTML = `
                <div class="loading-content" style="text-align: left;">
                    <h3><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg> Save Preset</h3>
                    <input type="text" class="modal-input" placeholder="Preset Name" style="width: 100%; margin: 15px 0; padding: 10px; border: 2px solid var(--border); border-radius: 8px; background: var(--surface-2); color: var(--text);">
                    <div style="display: flex; justify-content: flex-end; gap: 10px;">
                        <button class="secondary-btn cancel-btn" style="padding: 8px 16px;">Cancel</button>
                        <button class="process-btn save-btn" style="padding: 8px 16px;">Save</button>
                    </div>
                </div>
            `;
             
            const input = modal.querySelector('.modal-input');
            const cancelBtn = modal.querySelector('.cancel-btn');
            const saveBtn = modal.querySelector('.save-btn');
             
            cancelBtn.onclick = () => modal.remove();
             
            const doSave = () => {
                const presetName = input.value.trim();
                if (presetName) {
                    const presets = JSON.parse(localStorage.getItem('watermark_presets') || '{}');
                    presets[presetName] = { ...appState.settings };
                    localStorage.setItem('watermark_presets', JSON.stringify(presets));
                    ErrorHandler.show(`"${presetName}" preset saved`, 'success');
                    modal.remove();
                } else {
                    input.focus();
                    input.style.borderColor = 'var(--error)';
                }
            };
             
            saveBtn.onclick = doSave;
            input.onkeydown = (e) => { if (e.key === 'Enter') doSave(); };
             
            document.body.appendChild(modal);
            input.focus();
        }

        function loadPreset() {
            const presets = JSON.parse(localStorage.getItem('watermark_presets') || '{}');
            const presetNames = Object.keys(presets);
            
            if (presetNames.length === 0) {
                ErrorHandler.show('No saved presets found');
                return;
            }

            const modal = document.createElement('div');
            modal.className = 'loading-overlay';
            
            const listHtml = presetNames.map(name => `
                <div class="preset-item" style="display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid var(--border);">
                    <span style="font-weight: 500;">${name}</span>
                    <div style="display: flex; gap: 8px;">
                        <button class="process-btn load-btn" data-name="${name}" style="padding: 6px 12px; font-size: 0.85rem;">Load</button>
                        <button class="remove-btn delete-btn" data-name="${name}" style="position: static; opacity: 1; width: auto; padding: 6px 12px; height: auto; border-radius: 6px; background: var(--error); color: white; display: flex; align-items: center; justify-content: center;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    </div>
                </div>
            `).join('');
            
            modal.innerHTML = `
                <div class="loading-content" style="text-align: left; max-width: 450px; width: 90%;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg> Load Preset</h3>
                        <button class="secondary-btn close-btn" style="padding: 5px 10px;">‚úï</button>
                    </div>
                    <div class="preset-list" style="max-height: 400px; overflow-y: auto; margin-bottom: 15px; background: var(--surface-2); border-radius: 8px;">
                        ${listHtml}
                    </div>
                </div>
            `;
            
            modal.querySelector('.close-btn').onclick = () => modal.remove();
            
            modal.onclick = (e) => {
                if (e.target.classList.contains('load-btn')) {
                    const name = e.target.dataset.name;
                    appState.settings = { ...presets[name] };
                    updateAllSliders();
                    updatePreview();
                    ErrorHandler.show(`"${name}" preset loaded`, 'success');
                    modal.remove();
                } else if (e.target.classList.contains('delete-btn') || e.target.closest('.delete-btn')) {
                    const btn = e.target.closest('.delete-btn');
                    const name = btn.dataset.name;
                    if (confirm(`Delete preset "${name}"?`)) {
                        delete presets[name];
                        localStorage.setItem('watermark_presets', JSON.stringify(presets));
                        modal.remove();
                        loadPreset(); // Refresh
                    }
                } else if (e.target === modal) {
                    modal.remove();
                }
            };
            
            document.body.appendChild(modal);
        }

        function resetSettings() {
            appState.settings = {
                count: 5,
                opacity: 50,
                size: 15,
                rotation: 0,
                mode: 'position',
                position: 'top-left',
                customPos: { x: 0.5, y: 0.5 },
                blendMode: 'normal',
                padding: 20,
                textContent: '',
                textSize: 24,
                fontFamily: 'Arial',
                textColor: '#ffffff',
                textStroke: 2,
                textStrokeColor: '#000000',
                shadowBlur: 0,
                shadowOffset: 0,
                shadowColor: '#000000',
                brightness: 100,
                contrast: 100,
                saturation: 100
            };
            
            updateAllSliders();
            updatePreview();
            
            ErrorHandler.show('Settings reset', 'info');
        }

        function updateAllSliders() {
            document.getElementById('countSlider').value = appState.settings.count;
            document.getElementById('countValue').textContent = appState.settings.count;
            
            document.getElementById('opacitySlider').value = appState.settings.opacity;
            document.getElementById('opacityValue').textContent = appState.settings.opacity;
            
            document.getElementById('sizeSlider').value = appState.settings.size;
            document.getElementById('sizeValue').textContent = appState.settings.size;
            
            document.getElementById('rotationSlider').value = appState.settings.rotation;
            document.getElementById('rotationValue').textContent = appState.settings.rotation;
            
            document.getElementById('paddingSlider').value = appState.settings.padding;
            document.getElementById('paddingValue').textContent = appState.settings.padding;
            
            // Text settings
            document.getElementById('textContent').value = appState.settings.textContent;
            document.getElementById('textSizeSlider').value = appState.settings.textSize;
            document.getElementById('textSizeValue').textContent = appState.settings.textSize;
            document.getElementById('fontFamily').value = appState.settings.fontFamily;
            document.getElementById('textColor').value = appState.settings.textColor;
            document.getElementById('textColorValue').textContent = appState.settings.textColor;
            document.getElementById('textStrokeSlider').value = appState.settings.textStroke;
            document.getElementById('textStrokeValue').textContent = appState.settings.textStroke;
            document.getElementById('textStrokeColor').value = appState.settings.textStrokeColor;
            document.getElementById('textStrokeColorValue').textContent = appState.settings.textStrokeColor;
            
            // Effects
            document.getElementById('shadowBlurSlider').value = appState.settings.shadowBlur;
            document.getElementById('shadowBlurValue').textContent = appState.settings.shadowBlur;
            document.getElementById('shadowOffsetSlider').value = appState.settings.shadowOffset;
            document.getElementById('shadowOffsetValue').textContent = appState.settings.shadowOffset;
            document.getElementById('shadowColor').value = appState.settings.shadowColor;
            document.getElementById('shadowColorValue').textContent = appState.settings.shadowColor;
            document.getElementById('brightnessSlider').value = appState.settings.brightness;
            document.getElementById('brightnessValue').textContent = appState.settings.brightness;
            document.getElementById('contrastSlider').value = appState.settings.contrast;
            document.getElementById('contrastValue').textContent = appState.settings.contrast;
            document.getElementById('saturationSlider').value = appState.settings.saturation;
            document.getElementById('saturationValue').textContent = appState.settings.saturation;
            
            document.getElementById('blendMode').value = appState.settings.blendMode;
        }

        // Clear all images function
        function clearAllImages(event) {
            // Prevent the upload box click event
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            appState.mainImages = [];
            appState.watermark = null;
            
            // Reset upload boxes
            const mainBox = elements.mainImageBox;
            const watermarkBox = elements.watermarkBox;
            
            // Reset main image box
            mainBox.classList.remove('has-image');
            mainBox.innerHTML = `
                <div class="upload-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                        <circle cx="12" cy="13" r="4"/>
                    </svg>
                </div>
                <h3>Upload Main Images</h3>
                <p>Click or drag images here (PNG, JPG, WEBP)</p>
                <p style="font-size: 0.85rem; color: var(--text-muted);">Max size: 10MB</p>
                <input type="file" id="mainImageInput" accept="image/*" multiple aria-label="Select main image files">
                <div class="image-gallery" id="mainGallery" role="list"></div>
                <button class="clear-images-btn" onclick="clearAllImages(event)" style="display: none; margin-top: 15px; padding: 8px 16px; background: var(--error); color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 10; position: relative;" id="clearImagesBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px;">
                        <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14zM10 11v6M14 11v6"/>
                    </svg>
                    Clear All
                </button>
            `;
            
            // Reset watermark box
            watermarkBox.classList.remove('has-image');
            watermarkBox.innerHTML = `
                <div class="upload-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
                    </svg>
                </div>
                <h3>Upload Watermark/Logo</h3>
                <p>We recommend transparent PNG logos</p>
                <p style="font-size: 0.85rem; color: var(--text-muted);">Max size: 5MB</p>
                <input type="file" id="watermarkInput" accept="image/*" aria-label="Select watermark file">
            `;
            
            // Re-acquire DOM elements after innerHTML change
            elements.mainImageInput = document.getElementById('mainImageInput');
            elements.watermarkInput = document.getElementById('watermarkInput');
            elements.mainGallery = document.getElementById('mainGallery');
            
            // Re-setup event listeners
            setupFileInputs();
            setupClickHandlers();
            
            updateMainGallery();
            updateProcessButtons();
            updatePreview();
            
            ErrorHandler.show('All images cleared', 'info', 2000);
        }

        // Preset System - Apply Preset
        function applyPreset(presetType) {
            const presets = {
                subtle: {
                    count: 3,
                    opacity: 25,
                    size: 8,
                    rotation: -15,
                    mode: 'random',
                    position: 'bottom-right',
                    blendMode: 'multiply',
                    padding: 30
                },
                standard: {
                    count: 5,
                    opacity: 50,
                    size: 15,
                    rotation: 0,
                    mode: 'position',
                    position: 'bottom-right',
                    blendMode: 'normal',
                    padding: 20
                },
                bold: {
                    count: 1,
                    opacity: 80,
                    size: 25,
                    rotation: 0,
                    mode: 'position',
                    position: 'center',
                    blendMode: 'normal',
                    padding: 10
                },
                corner: {
                    count: 1,
                    opacity: 60,
                    size: 12,
                    rotation: 0,
                    mode: 'position',
                    position: 'bottom-right',
                    blendMode: 'normal',
                    padding: 15
                }
            };

            

            if (presets[presetType]) {
                // Update settings
                Object.assign(appState.settings, presets[presetType]);
                
                // Update UI
                updateAllSliders();
                updateModeButtons();
                updatePositionButtons();
                updatePreview();
                
                // Visual feedback
                document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-preset="${presetType}"]`).classList.add('active');
                
                ErrorHandler.show(`"${presetType.toUpperCase()}" preset applied`, 'success', 2000);
                appState.saveState();
            }
        }

        // Favorites System
        function saveToFavorites() {
            const favoriteName = prompt('Favorite setting name:', 'Favorite ' + (Date.now().toString().slice(-4)));
            if (favoriteName) {
                const favorites = JSON.parse(localStorage.getItem('watermark_favorites') || '{}');
                favorites[favoriteName] = {
                    settings: { ...appState.settings },
                    timestamp: Date.now(),
                    preview: generatePreviewThumbnail()
                };
                localStorage.setItem('watermark_favorites', JSON.stringify(favorites));
                
                ErrorHandler.show(`"${favoriteName}" added to favorites <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>`, 'success');
                updateFavoritesList();
            }
        }

        // Generate preview thumbnail for favorites
        function generatePreviewThumbnail() {
            if (appState.mainImages.length === 0) return null;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 100;
            canvas.height = 75;
            
            // Draw mini preview
            ctx.drawImage(appState.mainImages[0].img, 0, 0, 100, 75);
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = '#666';
            ctx.fillRect(80, 60, 15, 10);
            
            return canvas.toDataURL('image/jpeg', 0.5);
        }

        // Update favorites list in UI
        function updateFavoritesList() {
            const favorites = JSON.parse(localStorage.getItem('watermark_favorites') || '{}');
            // Implementation for favorites dropdown/list can be added here
            // Silent update - favorites count: Object.keys(favorites).length
        }

        // Mode and Position Button Updates
        function updateModeButtons() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });
            const activeBtn = document.querySelector(`[onclick*="'${appState.settings.mode}'"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.setAttribute('aria-pressed', 'true');
            }
        }

        function updatePositionButtons() {
            document.querySelectorAll('.position-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });
            const activeBtn = document.querySelector(`[onclick*="'${appState.settings.position}'"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.setAttribute('aria-pressed', 'true');
            }
        }

        // Advanced Export System
        function setupExportTab() {
            // JPG Quality Slider
            const jpgSlider = document.getElementById('jpgQualitySlider');
            const jpgValue = document.getElementById('jpgQualityValue');
            jpgSlider.addEventListener('input', (e) => {
                jpgValue.textContent = e.target.value;
            });

            // WEBP Quality Slider
            const webpSlider = document.getElementById('webpQualitySlider');
            const webpValue = document.getElementById('webpQualityValue');
            webpSlider.addEventListener('input', (e) => {
                webpValue.textContent = e.target.value;
            });

            // Performance Mode
            const perfMode = document.getElementById('performanceMode');
            perfMode.addEventListener('change', (e) => {
                const mode = e.target.value;
                applyPerformanceMode(mode);
            });
        }

        // Apply Performance Mode
        function applyPerformanceMode(mode) {
            switch (mode) {
                case 'quality':
                    document.getElementById('jpgQualitySlider').value = 100;
                    document.getElementById('webpQualitySlider').value = 95;
                    break;
                case 'balanced':
                    document.getElementById('jpgQualitySlider').value = 90;
                    document.getElementById('webpQualitySlider').value = 85;
                    break;
                case 'speed':
                    document.getElementById('jpgQualitySlider').value = 75;
                    document.getElementById('webpQualitySlider').value = 70;
                    break;
            }
            
            // Update display values
            document.getElementById('jpgQualityValue').textContent = document.getElementById('jpgQualitySlider').value;
            document.getElementById('webpQualityValue').textContent = document.getElementById('webpQualitySlider').value;
            
            ErrorHandler.show(`Performance mode: ${mode}`, 'info', 2000);
        }

        // Multi-format download with progress
        async function downloadAllFormats() {
            const exportOptions = {
                png: document.getElementById('exportPNG').checked,
                jpg: document.getElementById('exportJPG').checked,
                webp: document.getElementById('exportWEBP').checked,
                jpgQuality: parseInt(document.getElementById('jpgQualitySlider').value) / 100,
                webpQuality: parseInt(document.getElementById('webpQualitySlider').value) / 100
            };

            if (!exportOptions.png && !exportOptions.jpg && !exportOptions.webp) {
                ErrorHandler.show('You must select at least one format', 'warning');
                return;
            }

            const zip = new JSZip();
            const progressBar = document.createElement('div');
            progressBar.className = 'advanced-progress';
            progressBar.innerHTML = `
                <div class="progress-details">
                    <span>Multi-format export...</span>
                    <span class="speed-indicator">Preparing...</span>
                </div>
                <div class="progress-bar" style="display: block;">
                    <div class="progress-fill" style="width: 0%;">0%</div>
                </div>
            `;
            
            document.querySelector('.process-section').appendChild(progressBar);

            try {
                const startTime = performance.now();
                const totalFiles = appState.processedResults.length *
                    (exportOptions.png + exportOptions.jpg + exportOptions.webp);
                let processed = 0;

                for (const result of appState.processedResults) {
                    const baseName = result.originalName.replace(/\.[^/.]+$/, '');
                    
                    if (exportOptions.png) {
                        zip.file(`PNG/${baseName}.png`, result.dataURL.split(',')[1], { base64: true });
                        processed++;
                        updateExportProgress(progressBar, processed, totalFiles, startTime);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    if (exportOptions.jpg) {
                        const jpgData = await convertToFormat(result.dataURL, 'jpeg', exportOptions.jpgQuality);
                        zip.file(`JPG/${baseName}.jpg`, jpgData.split(',')[1], { base64: true });
                        processed++;
                        updateExportProgress(progressBar, processed, totalFiles, startTime);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    if (exportOptions.webp) {
                        const webpData = await convertToFormat(result.dataURL, 'webp', exportOptions.webpQuality);
                        zip.file(`WEBP/${baseName}.webp`, webpData.split(',')[1], { base64: true });
                        processed++;
                        updateExportProgress(progressBar, processed, totalFiles, startTime);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }

                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `watermarked_multiformat_${Date.now()}.zip`;
                link.click();

                ErrorHandler.show(`${totalFiles} files exported successfully! <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><polyline points="20 6 9 17 4 12"></polyline></svg>`, 'success');
            } catch (error) {
                ErrorHandler.show('Export error: ' + error.message, 'error');
            } finally {
                progressBar.remove();
            }
        }

        // Update export progress
        function updateExportProgress(progressBar, processed, total, startTime) {
            const percentage = Math.round((processed / total) * 100);
            const elapsed = (performance.now() - startTime) / 1000;
            const speed = processed / elapsed;
            const remaining = (total - processed) / speed;
            
            const progressFill = progressBar.querySelector('.progress-fill');
            const speedIndicator = progressBar.querySelector('.speed-indicator');
            
            progressFill.style.width = percentage + '%';
            progressFill.textContent = percentage + '%';
            speedIndicator.textContent = `${speed.toFixed(1)} file/s - ${remaining.toFixed(0)}s remaining`;
        }

        // Convert format helper
        async function convertToFormat(dataURL, format, quality) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    if (format === 'jpeg') {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    
                    ctx.drawImage(img, 0, 0);
                    
                    const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/webp';
                    resolve(canvas.toDataURL(mimeType, quality));
                };
                img.src = dataURL;
            });
        }

        // Undo System
        function undoLast() {
            appState.undoState();
        }

        // Help System
        function showHelp() {
            const helpContent = `
            <div style="max-width: 600px; line-height: 1.6;">
                <h2>üé® Watermark Application Help</h2>
                <h3>üìã How to Use:</h3>
                <ol>
                    <li><strong>Upload Images:</strong> Click the main image box or drag and drop</li>
                    <li><strong>Add Watermark:</strong> Upload or write your logo/text watermark</li>
                    <li><strong>Adjust Settings:</strong> Configure size, opacity, position and other settings</li>
                    <li><strong>Preview:</strong> See the result with real-time preview</li>
                    <li><strong>Process:</strong> Batch process all images</li>
                    <li><strong>Download:</strong> Download individually or as ZIP</li>
                </ol>
                
                <h3>‚öôÔ∏è Features:</h3>
                <ul>
                    <li><strong>Multi-format:</strong> PNG, JPG, WEBP support</li>
                    <li><strong>Text Watermark:</strong> Custom text, fonts and colors</li>
                    <li><strong>Advanced Effects:</strong> Shadow, blur, color adjustments</li>
                    <li><strong>Preset System:</strong> Save/load settings</li>
                    <li><strong>Batch Processing:</strong> Hundreds of images at once</li>
                </ul>

                <h3>‚å®Ô∏è Keyboard Shortcuts:</h3>
                <ul>
                    <li><kbd>Ctrl+O</kbd> - Select file</li>
                    <li><kbd>Ctrl+Enter</kbd> - Process</li>
                    <li><kbd>Ctrl+Z</kbd> - Undo</li>
                    <li><kbd>Ctrl+T</kbd> - Toggle theme</li>
                    <li><kbd>F1</kbd> - This help</li>
                </ul>
            </div>
            `;
            
            const helpModal = document.createElement('div');
            helpModal.className = 'loading-overlay';
            helpModal.innerHTML = `
                <div class="loading-content" style="max-height: 80vh; overflow-y: auto;">
                    ${helpContent}
                    <button onclick="this.closest('.loading-overlay').remove()"
                            style="margin-top: 20px; padding: 10px 20px; border: none; border-radius: 8px; background: var(--primary); color: white; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(helpModal);
        }

        // Keyboard Shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey) {
                    switch (e.key) {
                        case 'o':
                            e.preventDefault();
                            elements.mainImageInput.click();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            if (!elements.processBtn.disabled) {
                                processAllImages();
                            }
                            break;
                        case 'z':
                            e.preventDefault();
                            undoLast();
                            break;
                        case 't':
                            e.preventDefault();
                            toggleTheme();
                            break;
                    }
                } else if (e.key === 'F1') {
                    e.preventDefault();
                    showHelp();
                }
            });
        }

        // Smart Suggestions System
        class SmartSuggestions {
            static analyzeImage(img) {
                const aspectRatio = img.width / img.height;
                const megapixels = (img.width * img.height) / (1024 * 1024);
                const isLandscape = aspectRatio > 1.2;
                const isPortrait = aspectRatio < 0.8;
                
                return { aspectRatio, megapixels, isLandscape, isPortrait };
            }
            
            static suggestOptimalSettings(imageAnalysis) {
                const suggestions = {};
                
                // Size suggestions based on image size
                if (imageAnalysis.megapixels > 5) {
                    suggestions.size = { value: 12, reason: 'Small watermark recommended for high resolution' };
                } else if (imageAnalysis.megapixels < 1) {
                    suggestions.size = { value: 20, reason: 'Large watermark recommended for low resolution' };
                } else {
                    suggestions.size = { value: 15, reason: 'Standard size for medium resolution' };
                }
                
                // Position suggestions
                if (imageAnalysis.isLandscape) {
                    suggestions.position = { value: 'bottom-right', reason: 'Bottom right corner recommended for landscape images' };
                } else if (imageAnalysis.isPortrait) {
                    suggestions.position = { value: 'bottom-center', reason: 'Bottom center recommended for portrait images' };
                } else {
                    suggestions.position = { value: 'bottom-right', reason: 'Bottom right corner recommended for square images' };
                }
                
                // Opacity suggestions
                suggestions.opacity = { value: 40, reason: 'Medium transparency for professional look' };
                
                return suggestions;
            }
            
            static showSuggestions(suggestions) {
                const suggestionHtml = Object.keys(suggestions).map(key => {
                    const suggestion = suggestions[key];
                    return `
                        <div class="suggestion-item">
                            <strong>${key.toUpperCase()}:</strong> ${suggestion.value}
                            <br><small>${suggestion.reason}</small>
                            <button class="apply-suggestion-btn" onclick="applySuggestion('${key}', '${suggestion.value}')">
                                Apply
                            </button>
                        </div>
                    `;
                }).join('');
                
                const modal = document.createElement('div');
                modal.className = 'loading-overlay';
            modal.innerHTML = `
                <div class="loading-content">
                    <h3><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><rect x="3" y="11" width="18" height="10" rx="2"></rect><circle cx="12" cy="5" r="2"></circle><path d="M12 7v4"></path><line x1="8" y1="16" x2="8" y2="16"></line><line x1="16" y1="16" x2="16" y2="16"></line></svg> Smart Suggestions</h3>
                    <p>Optimized settings for your image:</p>
                    ${suggestionHtml}
                    <button onclick="this.closest('.loading-overlay').remove()"
                            style="margin-top: 20px; padding: 10px 20px; border: none; border-radius: 8px; background: var(--secondary); color: white; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
                
                document.body.appendChild(modal);
            }
        }
        
        // Apply smart suggestion
        function applySuggestion(settingType, value) {
            switch (settingType) {
                case 'size':
                    appState.settings.size = parseInt(value);
                    document.getElementById('sizeSlider').value = value;
                    document.getElementById('sizeValue').textContent = value;
                    break;
                case 'position':
                    appState.settings.position = value;
                    updatePositionButtons();
                    break;
                case 'opacity':
                    appState.settings.opacity = parseInt(value);
                    document.getElementById('opacitySlider').value = value;
                    document.getElementById('opacityValue').textContent = value;
                    break;
            }
            
            updatePreview();
            document.querySelector('.loading-overlay').remove();
            ErrorHandler.show('Suggestions applied!', 'success', 2000);
        }
        
        // Quick Actions System
        function showQuickActions() {
            const modal = document.createElement('div');
            modal.className = 'loading-overlay';
            modal.innerHTML = `
                <div class="loading-content">
                    <h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: text-bottom;"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg> Quick Actions</h3>
                    <div style="display: grid; gap: 15px; margin: 20px 0;">
                        <button class="process-btn" onclick="quickLogo()" style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line></svg>
                            Add Logo
                        </button>
                        <button class="process-btn" onclick="quickCopyright()" style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M15 9.354a4 4 0 1 0 0 5.292"></path></svg>
                            Copyright
                        </button>
                        <button class="process-btn" onclick="quickWatermark()" style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                            Classic Watermark
                        </button>
                        <button class="process-btn secondary-btn" onclick="autoOptimize()" style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="10" rx="2"></rect><circle cx="12" cy="5" r="2"></circle><path d="M12 7v4"></path><line x1="8" y1="16" x2="8" y2="16"></line><line x1="16" y1="16" x2="16" y2="16"></line></svg>
                            Auto Optimize
                        </button>
                    </div>
                    <button onclick="this.closest('.loading-overlay').remove()"
                            style="padding: 8px 16px; border: none; border-radius: 8px; background: var(--secondary); color: white; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Quick action functions
        function quickLogo() {
            appState.settings.mode = 'position';
            appState.settings.position = 'bottom-right';
            appState.settings.size = 15;
            appState.settings.opacity = 80;
            updateAllSliders();
            updateModeButtons();
            updatePositionButtons();
            updatePreview();
            document.querySelector('.loading-overlay').remove();
            ErrorHandler.show('Logo settings applied', 'success');
        }
        
        function quickCopyright() {
            appState.settings.textContent = `¬© ${new Date().getFullYear()} All rights reserved`;
            appState.settings.mode = 'position';
            appState.settings.position = 'bottom-center';
            appState.settings.textSize = 16;
            appState.settings.opacity = 60;
            updateAllSliders();
            updateModeButtons();
            updatePositionButtons();
            updatePreview();
            document.querySelector('.loading-overlay').remove();
            ErrorHandler.show('Copyright text added', 'success');
        }
        
        function quickWatermark() {
            appState.settings.mode = 'pattern';
            appState.settings.opacity = 20;
            appState.settings.rotation = -30;
            appState.settings.textContent = 'WATERMARK';
            appState.settings.textSize = 48;
            updateAllSliders();
            updateModeButtons();
            updatePreview();
            document.querySelector('.loading-overlay').remove();
            ErrorHandler.show('Classic watermark applied', 'success');
        }
        
        function autoOptimize() {
            if (appState.mainImages.length > 0) {
                const analysis = SmartSuggestions.analyzeImage(appState.mainImages[0].img);
                const suggestions = SmartSuggestions.suggestOptimalSettings(analysis);
                
                // Auto-apply suggestions
                Object.keys(suggestions).forEach(key => {
                    applySuggestion(key, suggestions[key].value);
                });
                
                document.querySelector('.loading-overlay').remove();
                ErrorHandler.show('Auto optimization completed!', 'success');
            } else {
                ErrorHandler.show('Please upload an image first', 'warning');
            }
        }
        
        // Enhanced image loading with smart suggestions
        function enhancedLoadImage(file, type) {
            loadImage(file, type).then(() => {
                if (type === 'main' && appState.mainImages.length === 1) {
                    // Show smart suggestions for first image
                    setTimeout(() => {
                        const analysis = SmartSuggestions.analyzeImage(appState.mainImages[0].img);
                        const suggestions = SmartSuggestions.suggestOptimalSettings(analysis);
                        SmartSuggestions.showSuggestions(suggestions);
                    }, 1000);
                }
            });
        }

        // Canvas Interactions (Drag & Drop Watermark)
        function setupCanvasInteractions() {
            const canvas = elements.previewCanvas;
            let isDragging = false;

            canvas.style.cursor = 'move';

            canvas.addEventListener('mousedown', (e) => {
                if (appState.mainImages.length === 0) return;
                isDragging = true;
                canvas.style.cursor = 'grabbing';
                
                appState.settings.mode = 'position';
                appState.settings.position = 'custom';
                updateModeButtons();
                updatePositionButtons();
                
                handleDrag(e);
            });

            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault(); // Prevent selection
                    handleDrag(e);
                }
            });

            window.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = 'move';
                    appState.saveState();
                }
            });
            
            function handleDrag(e) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                
                appState.settings.customPos.x = Math.max(0, Math.min(1, x));
                appState.settings.customPos.y = Math.max(0, Math.min(1, y));
                
                updatePreview();
            }
        }

        // Initialize Application
        function initializeApp() {
            initializeTheme();
            setupDragAndDrop();
            setupClickHandlers();
            setupFileInputs();
            setupSettings();
            setupCanvasInteractions();
            setupKeyboardShortcuts();
            setupExportTab();
            
            // Update state
            appState.updateUndoButton();
            updateProcessButtons();
            updateFavoritesList();
            
            // Add quick actions button to header
            const quickActionsBtn = document.createElement('button');
            quickActionsBtn.className = 'help-btn';
            quickActionsBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 5px;"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg> Quick Actions';
            quickActionsBtn.onclick = showQuickActions;
            document.querySelector('.header-controls').insertBefore(
                quickActionsBtn,
                document.querySelector('.help-btn')
            );
            
            // Show welcome message with tips
            setTimeout(() => {
                const welcomeMsg = `
                    <div style="display: flex; flex-direction: column; gap: 5px;">
                        <strong>Watermark Application is ready!</strong>
                        <span><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><line x1="9" y1="18" x2="15" y2="18"></line><line x1="10" y1="22" x2="14" y2="22"></line><path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 9.5 6 4.65 4.65 0 0 0 8 11.5c0 1.3 1 2.4 1.5 4.5"></path></svg> Tip: Smart suggestions will be shown when you upload your first image.</span>
                        <span><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg> Use the Quick Actions button to quickly access common settings.</span>
                        <span>Press F1 for detailed help.</span>
                    </div>
                `;
                ErrorHandler.show(welcomeMsg, 'info', 6000);
            }, 1000);
        }

        // Start the application
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>